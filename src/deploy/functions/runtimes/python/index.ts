// TODOs in this file before productizing:
// 1. We probably need to make the virtualenv configurable. I don't like sticking with "py3" because we have
//    no clue what we'll do with py4.
// 2. It might be good to come up with a way for "run" to set the right side-effects of virtualenv without
//    having to shell exec.
// 3. Codegen has to know about the module name for the customers' code. "sample" is probably not great.
import { promisify } from "util";
import * as cp from "child_process";
import * as fs from "fs";
import * as path from "path";
import * as portfinder from "portfinder";
import * as spawn from "cross-spawn";

import { FirebaseError } from "../../../../error";
import { Options} from "../../../../options"
import * as args from "../../args"
import * as backend from "../../backend";
import * as discovery from "../discovery";
import * as runtimes from ".."

export const LATEST_VERSION: runtimes.Runtime = "python39";
export const PYENV = "py3"

export function run(command: string, functionsDir: string, opts?: cp.SpawnOptions): cp.ChildProcess & { exit(): Promise<void> } {
  const child = spawn("source", [path.join(functionsDir, PYENV, "bin", "activate"), "&&", ...command.split(" ")], {
    shell: true,
    cwd: functionsDir,
    stdio: "inherit",
    ...opts,
  });
  (child as any).exit = () => {
    return new Promise((resolve, reject) => {
      child.on("exit", resolve);
      child.on("error", reject);
    });
  }
  return child as cp.ChildProcess & { exit(): Promise<void> };
}

export function tryCreateDelegate(context: args.Context, options: Options): Promise<Delegate | undefined> {
  const sourceDirName = options.config.get("functions.source");
  const sourceDir = options.config.path(sourceDirName);

  const runtime = options.config.get("functions.runtime") as string;
  if (!runtime) {
    return Promise.resolve(undefined);
  }
  if (!runtime.startsWith("python")) {
    return Promise.resolve(undefined);
  }

  if (!runtimes.isValidRuntime(runtime)) {
    throw new FirebaseError(`Runtime ${runtime} is not a valid Python runtime`);
  }

  return Promise.resolve(new Delegate(sourceDir, context.projectId, runtime));
}

class Delegate {
  readonly name = "python";

  constructor(private readonly sourceDir: string, private readonly projectId: string, public readonly runtime: runtimes.Runtime) {}

  private modulesDir_: string = "";
  async modulesDir(): Promise<string> {
    if (!this.modulesDir_) {
      const child = run("python -c 'import firebase_functions; import os; print(os.path.dirname(firebase_functions.__file__))'", this.sourceDir, {
        stdio: [
          /* stdin= */ "ignore",
          /* stdout= */ "pipe",
          /* stderr= */ "inherit",
        ],
      });

      let out = "";
      child.stdout.on("data", (chunk) => {
        out = out + chunk.toString();
      });
      await child.exit();
      this.modulesDir_ = out.trimEnd();
    }

    return this.modulesDir_;
  }

  validate(): Promise<void> {
    return Promise.resolve();
  }

  async build(): Promise<void> {
    const codegen = path.join(await this.modulesDir(), "codegen.py");
    const functions = path.join(this.sourceDir, "main.py");
    const child = run(`python ${codegen} main.py`, this.sourceDir, {
      stdio: [
        /* stdin= */"ignore",
        /* stdout= */"pipe",
        /* stderr= */"inherit",
      ],
    });
    let program = "";
    child.stdout.on("data", chunk => {
      program = program + chunk.toString();
    });
    await child.exit();
    await promisify(fs.writeFile)(path.join(this.sourceDir, "autogenerated.py"), program);
  }

  watch(): Promise<() => Promise<void>> {
    return Promise.resolve(() => Promise.resolve());
  }

  serveAdmin(
    port: number,
    envs: backend.EnvironmentVariables,
  ): Promise<() => Promise<void>> {
    const child = run(`gunicorn -b localhost:${port} autogenerated:admin`, this.sourceDir, {
      env: {
        ...envs,
        ...process.env,
      },
      stdio: "inherit",
    });
    return Promise.resolve(async () => {
      // Why isn't SIGINT enough?
      child.kill("SIGKILL");
      await child.exit();
    });
  }

  async discoverSpec(
    configValues: backend.RuntimeConfigValues,
    envs: backend.EnvironmentVariables,
  ): Promise<backend.Backend> {
    let discovered = await discovery.detectFromYaml(this.sourceDir, this.projectId, this.runtime);
    if (!discovered) {
      const port = await promisify(portfinder.getPort)() as number;
      const kill = await this.serveAdmin(port, envs);
      try {
        discovered = await discovery.detectFromPort(port, this.projectId, this.runtime);
        console.log("Discovered", discovered);
      } finally {
        await kill();
      }
    }
    discovered.environmentVariables = envs;
    return discovered;
  }
}