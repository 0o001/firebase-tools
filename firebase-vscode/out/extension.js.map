{"version":3,"file":"extension.js","mappings":"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","sources":[".././node_modules/process/browser.js","../../src/emulator/constants.ts","../../src/api.ts","../external commonjs \"configstore\"","../../src/configstore.ts","../../src/error.ts","../../src/logger.ts","../../src/scopes.ts","../external commonjs \"ora\"","../external commonjs \"triple-beam\"","../../src/utils.ts","../external commonjs \"colorette\"","../external commonjs \"lodash\"","../external commonjs \"strip-ansi\"","../external commonjs \"winston\"","../webpack/bootstrap","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../external commonjs \"vscode\"","../external commonjs \"form-data\"","../external commonjs \"jsonwebtoken\"","../external commonjs \"open\"","../external commonjs \"portfinder\"","../external commonjs \"proxy-agent\"","../external commonjs \"retry\"","../external commonjs \"abort-controller\"","../external commonjs \"node-fetch\"","../../src/apiv2.ts","../external commonjs \"inquirer\"","../external commonjs \"uuid\"","../external commonjs \"universal-analytics\"","../../src/track.ts",".././src/extension.ts","../../src/auth.ts"],"sourcesContent":["// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","import { Emulators } from \"./types\";\n\nexport const DEFAULT_PORTS: { [s in Emulators]: number } = {\n  ui: 4000,\n  hub: 4400,\n  logging: 4500,\n  hosting: 5000,\n  functions: 5001,\n  extensions: 5001, // The Extensions Emulator runs on the same port as the Functions Emulator\n  firestore: 8080,\n  pubsub: 8085,\n  database: 9000,\n  auth: 9099,\n  storage: 9199,\n  eventarc: 9299,\n};\n\nexport const FIND_AVAILBLE_PORT_BY_DEFAULT: Record<Emulators, boolean> = {\n  ui: true,\n  hub: true,\n  logging: true,\n  hosting: true,\n  functions: false,\n  firestore: false,\n  database: false,\n  pubsub: false,\n  auth: false,\n  storage: false,\n  extensions: false,\n  eventarc: true,\n};\n\nexport const EMULATOR_DESCRIPTION: Record<Emulators, string> = {\n  ui: \"Emulator UI\",\n  hub: \"emulator hub\",\n  logging: \"Logging Emulator\",\n  hosting: \"Hosting Emulator\",\n  functions: \"Functions Emulator\",\n  firestore: \"Firestore Emulator\",\n  database: \"Database Emulator\",\n  pubsub: \"Pub/Sub Emulator\",\n  auth: \"Authentication Emulator\",\n  storage: \"Storage Emulator\",\n  extensions: \"Extensions Emulator\",\n  eventarc: \"Eventarc Emulator\",\n};\n\nexport const DEFAULT_HOST = \"localhost\";\n\nexport class Constants {\n  // GCP projects cannot start with 'demo' so we use 'demo-' as a prefix to denote\n  // an intentionally fake project.\n  static FAKE_PROJECT_ID_PREFIX = \"demo-\";\n  static FAKE_PROJECT_NUMBER = \"0\";\n\n  static DEFAULT_DATABASE_EMULATOR_NAMESPACE = \"fake-server\";\n\n  // Environment variable to override SDK/CLI to point at the Firestore emulator.\n  static FIRESTORE_EMULATOR_HOST = \"FIRESTORE_EMULATOR_HOST\";\n\n  // Alternative (deprecated) env var for Firestore Emulator.\n  static FIRESTORE_EMULATOR_ENV_ALT = \"FIREBASE_FIRESTORE_EMULATOR_ADDRESS\";\n\n  // Environment variable to override SDK/CLI to point at the Realtime Database emulator.\n  static FIREBASE_DATABASE_EMULATOR_HOST = \"FIREBASE_DATABASE_EMULATOR_HOST\";\n\n  // Environment variable to override SDK/CLI to point at the Firebase Auth emulator.\n  static FIREBASE_AUTH_EMULATOR_HOST = \"FIREBASE_AUTH_EMULATOR_HOST\";\n\n  // Environment variable to override SDK/CLI to point at the Firebase Storage emulator.\n  static FIREBASE_STORAGE_EMULATOR_HOST = \"FIREBASE_STORAGE_EMULATOR_HOST\";\n\n  // Environment variable to override SDK/CLI to point at the Firebase Storage emulator\n  // for firebase-admin <= 9.6.0. Unlike the FIREBASE_STORAGE_EMULATOR_HOST variable\n  // this one must start with 'http://'.\n  static CLOUD_STORAGE_EMULATOR_HOST = \"STORAGE_EMULATOR_HOST\";\n\n  // Environment variable to discover the eventarc emulator.\n  static PUBSUB_EMULATOR_HOST = \"PUBSUB_EMULATOR_HOST\";\n\n  // Environment variable to discover the eventarc emulator.\n  static CLOUD_EVENTARC_EMULATOR_HOST = \"CLOUD_EVENTARC_EMULATOR_HOST\";\n\n  // Environment variable to discover the Emulator HUB\n  static FIREBASE_EMULATOR_HUB = \"FIREBASE_EMULATOR_HUB\";\n  static FIREBASE_GA_SESSION = \"FIREBASE_GA_SESSION\";\n\n  static SERVICE_FIRESTORE = \"firestore.googleapis.com\";\n  static SERVICE_REALTIME_DATABASE = \"firebaseio.com\";\n  static SERVICE_PUBSUB = \"pubsub.googleapis.com\";\n  static SERVICE_EVENTARC = \"eventarc.googleapis.com\";\n  // Note: the service name below are here solely for logging purposes.\n  // There is not an emulator available for these.\n  static SERVICE_ANALYTICS = \"app-measurement.com\";\n  static SERVICE_AUTH = \"firebaseauth.googleapis.com\";\n  static SERVICE_CRASHLYTICS = \"fabric.io\";\n  static SERVICE_REMOTE_CONFIG = \"firebaseremoteconfig.googleapis.com\";\n  static SERVICE_STORAGE = \"storage.googleapis.com\";\n  static SERVICE_TEST_LAB = \"testing.googleapis.com\";\n\n  static getServiceName(service: string): string {\n    switch (service) {\n      case this.SERVICE_FIRESTORE:\n        return \"firestore\";\n      case this.SERVICE_REALTIME_DATABASE:\n        return \"database\";\n      case this.SERVICE_PUBSUB:\n        return \"pubsub\";\n      case this.SERVICE_ANALYTICS:\n        return \"analytics\";\n      case this.SERVICE_AUTH:\n        return \"auth\";\n      case this.SERVICE_CRASHLYTICS:\n        return \"crashlytics\";\n      case this.SERVICE_REMOTE_CONFIG:\n        return \"remote config\";\n      case this.SERVICE_STORAGE:\n        return \"storage\";\n      case this.SERVICE_TEST_LAB:\n        return \"test lab\";\n      case this.SERVICE_EVENTARC:\n        return \"eventarc\";\n      default:\n        return service;\n    }\n  }\n\n  static getDefaultHost(): string {\n    return DEFAULT_HOST;\n  }\n\n  static getDefaultPort(emulator: Emulators): number {\n    return DEFAULT_PORTS[emulator];\n  }\n\n  static description(name: Emulators): string {\n    return EMULATOR_DESCRIPTION[name];\n  }\n\n  static isDemoProject(projectId?: string): boolean {\n    return !!projectId && projectId.startsWith(this.FAKE_PROJECT_ID_PREFIX);\n  }\n}\n","import { Constants } from \"./emulator/constants\";\nimport { logger } from \"./logger\";\nimport * as scopes from \"./scopes\";\nimport * as utils from \"./utils\";\n\nlet commandScopes = new Set<string>();\n\nexport const authProxyOrigin = utils.envOverride(\n  \"FIREBASE_AUTHPROXY_URL\",\n  \"https://auth.firebase.tools\"\n);\n// \"In this context, the client secret is obviously not treated as a secret\"\n// https://developers.google.com/identity/protocols/OAuth2InstalledApp\nexport const clientId = utils.envOverride(\n  \"FIREBASE_CLIENT_ID\",\n  \"563584335869-fgrhgmd47bqnekij5i8b5pr03ho849e6.apps.googleusercontent.com\"\n);\nexport const clientSecret = utils.envOverride(\"FIREBASE_CLIENT_SECRET\", \"j9iVZfS8kkCEFUPaAeJV0sAi\");\nexport const cloudbillingOrigin = utils.envOverride(\n  \"FIREBASE_CLOUDBILLING_URL\",\n  \"https://cloudbilling.googleapis.com\"\n);\nexport const cloudloggingOrigin = utils.envOverride(\n  \"FIREBASE_CLOUDLOGGING_URL\",\n  \"https://logging.googleapis.com\"\n);\nexport const cloudMonitoringOrigin = utils.envOverride(\n  \"CLOUD_MONITORING_URL\",\n  \"https://monitoring.googleapis.com\"\n);\nexport const containerRegistryDomain = utils.envOverride(\"CONTAINER_REGISTRY_DOMAIN\", \"gcr.io\");\nexport const artifactRegistryDomain = utils.envOverride(\n  \"ARTIFACT_REGISTRY_DOMAIN\",\n  \"https://artifactregistry.googleapis.com\"\n);\nexport const appDistributionOrigin = utils.envOverride(\n  \"FIREBASE_APP_DISTRIBUTION_URL\",\n  \"https://firebaseappdistribution.googleapis.com\"\n);\nexport const appengineOrigin = utils.envOverride(\n  \"FIREBASE_APPENGINE_URL\",\n  \"https://appengine.googleapis.com\"\n);\nexport const authOrigin = utils.envOverride(\"FIREBASE_AUTH_URL\", \"https://accounts.google.com\");\nexport const consoleOrigin = utils.envOverride(\n  \"FIREBASE_CONSOLE_URL\",\n  \"https://console.firebase.google.com\"\n);\nexport const deployOrigin = utils.envOverride(\n  \"FIREBASE_DEPLOY_URL\",\n  utils.envOverride(\"FIREBASE_UPLOAD_URL\", \"https://deploy.firebase.com\")\n);\nexport const dynamicLinksOrigin = utils.envOverride(\n  \"FIREBASE_DYNAMIC_LINKS_URL\",\n  \"https://firebasedynamiclinks.googleapis.com\"\n);\nexport const dynamicLinksKey = utils.envOverride(\n  \"FIREBASE_DYNAMIC_LINKS_KEY\",\n  \"AIzaSyB6PtY5vuiSB8MNgt20mQffkOlunZnHYiQ\"\n);\nexport const firebaseApiOrigin = utils.envOverride(\n  \"FIREBASE_API_URL\",\n  \"https://firebase.googleapis.com\"\n);\nexport const firebaseExtensionsRegistryOrigin = utils.envOverride(\n  \"FIREBASE_EXT_REGISTRY_ORIGIN\",\n  \"https://extensions-registry.firebaseapp.com\"\n);\nexport const firedataOrigin = utils.envOverride(\n  \"FIREBASE_FIREDATA_URL\",\n  \"https://mobilesdk-pa.googleapis.com\"\n);\nexport const firestoreOriginOrEmulator = utils.envOverride(\n  Constants.FIRESTORE_EMULATOR_HOST,\n  utils.envOverride(\"FIRESTORE_URL\", \"https://firestore.googleapis.com\"),\n  (val) => {\n    if (val.startsWith(\"http\")) {\n      return val;\n    }\n    return `http://${val}`;\n  }\n);\nexport const firestoreOrigin = utils.envOverride(\n  \"FIRESTORE_URL\",\n  \"https://firestore.googleapis.com\"\n);\nexport const functionsOrigin = utils.envOverride(\n  \"FIREBASE_FUNCTIONS_URL\",\n  \"https://cloudfunctions.googleapis.com\"\n);\nexport const functionsV2Origin = utils.envOverride(\n  \"FIREBASE_FUNCTIONS_V2_URL\",\n  \"https://cloudfunctions.googleapis.com\"\n);\nexport const runOrigin = utils.envOverride(\"CLOUD_RUN_URL\", \"https://run.googleapis.com\");\nexport const functionsDefaultRegion = utils.envOverride(\n  \"FIREBASE_FUNCTIONS_DEFAULT_REGION\",\n  \"us-central1\"\n);\nexport const cloudschedulerOrigin = utils.envOverride(\n  \"FIREBASE_CLOUDSCHEDULER_URL\",\n  \"https://cloudscheduler.googleapis.com\"\n);\nexport const cloudTasksOrigin = utils.envOverride(\n  \"FIREBASE_CLOUD_TAKS_URL\",\n  \"https://cloudtasks.googleapis.com\"\n);\nexport const pubsubOrigin = utils.envOverride(\n  \"FIREBASE_PUBSUB_URL\",\n  \"https://pubsub.googleapis.com\"\n);\nexport const googleOrigin = utils.envOverride(\n  \"FIREBASE_TOKEN_URL\",\n  utils.envOverride(\"FIREBASE_GOOGLE_URL\", \"https://www.googleapis.com\")\n);\nexport const hostingOrigin = utils.envOverride(\"FIREBASE_HOSTING_URL\", \"https://web.app\");\nexport const identityOrigin = utils.envOverride(\n  \"FIREBASE_IDENTITY_URL\",\n  \"https://identitytoolkit.googleapis.com\"\n);\nexport const iamOrigin = utils.envOverride(\"FIREBASE_IAM_URL\", \"https://iam.googleapis.com\");\nexport const extensionsOrigin = utils.envOverride(\n  \"FIREBASE_EXT_URL\",\n  \"https://firebaseextensions.googleapis.com\"\n);\nexport const realtimeOrigin = utils.envOverride(\"FIREBASE_REALTIME_URL\", \"https://firebaseio.com\");\nexport const rtdbManagementOrigin = utils.envOverride(\n  \"FIREBASE_RTDB_MANAGEMENT_URL\",\n  \"https://firebasedatabase.googleapis.com\"\n);\nexport const rtdbMetadataOrigin = utils.envOverride(\n  \"FIREBASE_RTDB_METADATA_URL\",\n  \"https://metadata-dot-firebase-prod.appspot.com\"\n);\nexport const remoteConfigApiOrigin = utils.envOverride(\n  \"FIREBASE_REMOTE_CONFIG_URL\",\n  \"https://firebaseremoteconfig.googleapis.com\"\n);\nexport const resourceManagerOrigin = utils.envOverride(\n  \"FIREBASE_RESOURCEMANAGER_URL\",\n  \"https://cloudresourcemanager.googleapis.com\"\n);\nexport const rulesOrigin = utils.envOverride(\n  \"FIREBASE_RULES_URL\",\n  \"https://firebaserules.googleapis.com\"\n);\nexport const runtimeconfigOrigin = utils.envOverride(\n  \"FIREBASE_RUNTIMECONFIG_URL\",\n  \"https://runtimeconfig.googleapis.com\"\n);\nexport const storageOrigin = utils.envOverride(\n  \"FIREBASE_STORAGE_URL\",\n  \"https://storage.googleapis.com\"\n);\nexport const firebaseStorageOrigin = utils.envOverride(\n  \"FIREBASE_FIREBASESTORAGE_URL\",\n  \"https://firebasestorage.googleapis.com\"\n);\nexport const hostingApiOrigin = utils.envOverride(\n  \"FIREBASE_HOSTING_API_URL\",\n  \"https://firebasehosting.googleapis.com\"\n);\nexport const cloudRunApiOrigin = utils.envOverride(\n  \"CLOUD_RUN_API_URL\",\n  \"https://run.googleapis.com\"\n);\nexport const serviceUsageOrigin = utils.envOverride(\n  \"FIREBASE_SERVICE_USAGE_URL\",\n  \"https://serviceusage.googleapis.com\"\n);\nexport const githubOrigin = utils.envOverride(\"GITHUB_URL\", \"https://github.com\");\nexport const githubApiOrigin = utils.envOverride(\"GITHUB_API_URL\", \"https://api.github.com\");\nexport const secretManagerOrigin = utils.envOverride(\n  \"CLOUD_SECRET_MANAGER_URL\",\n  \"https://secretmanager.googleapis.com\"\n);\nexport const githubClientId = utils.envOverride(\"GITHUB_CLIENT_ID\", \"89cf50f02ac6aaed3484\");\nexport const githubClientSecret = utils.envOverride(\n  \"GITHUB_CLIENT_SECRET\",\n  \"3330d14abc895d9a74d5f17cd7a00711fa2c5bf0\"\n);\n\n/** Gets scopes that have been set. */\nexport function getScopes(): string[] {\n  return Array.from(commandScopes);\n}\n\n/** Sets scopes for API calls. */\nexport function setScopes(sps: string[] = []): void {\n  commandScopes = new Set<string>([\n    scopes.EMAIL,\n    scopes.OPENID,\n    scopes.CLOUD_PROJECTS_READONLY,\n    scopes.FIREBASE_PLATFORM,\n  ]);\n  for (const s of sps) {\n    commandScopes.add(s);\n  }\n  logger.debug(\"> command requires scopes:\", Array.from(commandScopes));\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"configstore\");","import * as Configstore from \"configstore\";\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst pkg = require(\"../package.json\");\n\nexport const configstore = new Configstore(pkg.name);\n","import { defaultTo } from \"lodash\";\n\ninterface FirebaseErrorOptions {\n  children?: unknown[];\n  context?: unknown;\n  exit?: number;\n  original?: Error;\n  status?: number;\n}\n\nconst DEFAULT_CHILDREN: NonNullable<FirebaseErrorOptions[\"children\"]> = [];\nconst DEFAULT_EXIT: NonNullable<FirebaseErrorOptions[\"exit\"]> = 1;\nconst DEFAULT_STATUS: NonNullable<FirebaseErrorOptions[\"status\"]> = 500;\n\nexport class FirebaseError extends Error {\n  readonly children: unknown[];\n  readonly context: unknown | undefined;\n  readonly exit: number;\n  readonly message: string;\n  readonly name = \"FirebaseError\";\n  readonly original: Error | undefined;\n  readonly status: number;\n\n  constructor(message: string, options: FirebaseErrorOptions = {}) {\n    super();\n\n    this.children = defaultTo(options.children, DEFAULT_CHILDREN);\n    this.context = options.context;\n    this.exit = defaultTo(options.exit, DEFAULT_EXIT);\n    this.message = message;\n    this.original = options.original;\n    this.status = defaultTo(options.status, DEFAULT_STATUS);\n  }\n}\n\n/**\n * Checks if a FirebaseError is caused by attempting something\n * that requires billing enabled while billing is not enabled.\n */\nexport function isBillingError(e: {\n  context?: {\n    body?: {\n      error?: {\n        details?: {\n          type: string;\n          reason?: string;\n          violations?: { type: string }[];\n        }[];\n      };\n    };\n  };\n}): boolean {\n  return !!e.context?.body?.error?.details?.find((d) => {\n    return (\n      d.violations?.find((v) => v.type === \"serviceusage/billing-enabled\") ||\n      d.reason === \"UREQ_PROJECT_BILLING_NOT_FOUND\"\n    );\n  });\n}\n","import * as winston from \"winston\";\nimport * as Transport from \"winston-transport\";\n\nexport type LogLevel =\n  | \"error\"\n  | \"warn\"\n  | \"help\"\n  | \"data\"\n  | \"info\"\n  | \"debug\"\n  | \"prompt\"\n  | \"http\"\n  | \"verbose\"\n  | \"input\"\n  | \"silly\";\n\n// Extend the Winston log methods to support error signatures\nexport interface LogMethod extends winston.LogMethod {\n  (level: LogLevel, err: Error, ...meta: any[]): Logger;\n}\n\nexport interface LeveledLogMessage extends winston.LeveledLogMethod {\n  // We use empty log messages to create newlines\n  (): Logger;\n\n  // We transform Errors to strings dynamically\n  (err: Error, ...meta: any[]): Logger;\n}\n\nexport interface Logger {\n  log: LogMethod;\n\n  error: LeveledLogMessage;\n  warn: LeveledLogMessage;\n  help: LeveledLogMessage;\n  data: LeveledLogMessage;\n  info: LeveledLogMessage;\n  debug: LeveledLogMessage;\n  prompt: LeveledLogMessage;\n  http: LeveledLogMessage;\n  verbose: LeveledLogMessage;\n  input: LeveledLogMessage;\n  silly: LeveledLogMessage;\n\n  add(transport: Transport): Logger;\n  remove(transport: Transport): Logger;\n}\n\nfunction expandErrors(logger: winston.Logger): winston.Logger {\n  const oldLogFunc: winston.LogMethod = logger.log.bind(logger);\n  const newLogFunc: winston.LogMethod = function (\n    levelOrEntry: string | winston.LogEntry,\n    message?: string | Error,\n    ...meta: any[]\n  ): winston.Logger {\n    if (message && message instanceof Error) {\n      message = message.stack || message.message;\n      return oldLogFunc(levelOrEntry as string, message, ...meta);\n    }\n    // Overloads are weird in TypeScript. This method works so long as the original\n    // function isn't checking arguments.length.\n    return oldLogFunc(levelOrEntry as string, message as string, ...meta);\n  };\n  logger.log = newLogFunc;\n  return logger;\n}\n\nfunction annotateDebugLines(logger: winston.Logger): winston.Logger {\n  const debug: winston.LeveledLogMethod = logger.debug.bind(logger);\n  const newDebug: winston.LeveledLogMethod = function (\n    message: string | any,\n    ...meta: any[]\n  ): winston.Logger {\n    if (typeof message === \"string\") {\n      message = `[${new Date().toISOString()}] ${message || \"\"}`;\n    }\n    return debug(message, ...meta);\n  };\n  logger.debug = newDebug;\n  return logger;\n}\n\nconst rawLogger = winston.createLogger();\n// Set a default silent logger to suppress logs during tests\nrawLogger.add(new winston.transports.Console({ silent: true }));\nrawLogger.exitOnError = false;\n\n// The type system for TypeScript is a bit wonky. The type of winston.LeveledLogMessage\n// and winston.LogMessage is an interface of function overloads. There's no easy way to\n// extend that and also subclass Logger to change the return type of those methods to\n// allow error parameters.\n// Casting looks super dodgy, but it should be safe because we know the underlying code\n// handles all parameter types we care about.\nexport const logger = annotateDebugLines(expandErrors(rawLogger)) as unknown as Logger;\n","// default scopes\nexport const OPENID = \"openid\";\nexport const EMAIL = \"email\";\nexport const CLOUD_PROJECTS_READONLY =\n  \"https://www.googleapis.com/auth/cloudplatformprojects.readonly\";\nexport const FIREBASE_PLATFORM = \"https://www.googleapis.com/auth/firebase\";\n\n// incremental scopes\nexport const CLOUD_PLATFORM = \"https://www.googleapis.com/auth/cloud-platform\";\nexport const CLOUD_STORAGE = \"https://www.googleapis.com/auth/devstorage.read_write\";\nexport const CLOUD_PUBSUB = \"https://www.googleapis.com/auth/pubsub\";\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"ora\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"triple-beam\");","import * as _ from \"lodash\";\nimport * as url from \"url\";\nimport * as http from \"http\";\nimport * as clc from \"colorette\";\nimport * as ora from \"ora\";\nimport * as process from \"process\";\nimport { Readable } from \"stream\";\nimport * as winston from \"winston\";\nimport { SPLAT } from \"triple-beam\";\nimport { AssertionError } from \"assert\";\nconst stripAnsi = require(\"strip-ansi\");\n\nimport { configstore } from \"./configstore\";\nimport { FirebaseError } from \"./error\";\nimport { logger, LogLevel } from \"./logger\";\nimport { LogDataOrUndefined } from \"./emulator/loggingEmulator\";\nimport { Socket } from \"net\";\n\nconst IS_WINDOWS = process.platform === \"win32\";\nconst SUCCESS_CHAR = IS_WINDOWS ? \"+\" : \"✔\";\nconst WARNING_CHAR = IS_WINDOWS ? \"!\" : \"⚠\";\nconst ERROR_CHAR = IS_WINDOWS ? \"!!\" : \"⬢\";\nconst THIRTY_DAYS_IN_MILLISECONDS = 30 * 24 * 60 * 60 * 1000;\n\nexport const envOverrides: string[] = [];\n\n/**\n * Create a Firebase Console URL for the specified path and project.\n */\nexport function consoleUrl(project: string, path: string): string {\n  const api = require(\"./api\");\n  return `${api.consoleOrigin}/project/${project}${path}`;\n}\n\n/**\n * Trace up the ancestry of objects that have a `parent` key, finding the\n * first instance of the provided key.\n */\nexport function getInheritedOption(options: any, key: string): any {\n  let target = options;\n  while (target) {\n    if (target[key] !== undefined) {\n      return target[key];\n    }\n    target = target.parent;\n  }\n}\n\n/**\n * Override a value with supplied environment variable if present. A function\n * that returns the environment variable in an acceptable format can be\n * proivded. If it throws an error, the default value will be used.\n */\nexport function envOverride(\n  envname: string,\n  value: string,\n  coerce?: (value: string, defaultValue: string) => any\n): string {\n  const currentEnvValue = process.env[envname];\n  if (currentEnvValue && currentEnvValue.length) {\n    envOverrides.push(envname);\n    if (coerce) {\n      try {\n        return coerce(currentEnvValue, value);\n      } catch (e: any) {\n        return value;\n      }\n    }\n    return currentEnvValue;\n  }\n  return value;\n}\n\n/**\n * Get the full URL to a path in the database or database emulator.\n */\nexport function getDatabaseUrl(origin: string, namespace: string, pathname: string): string {\n  const withPath = url.resolve(origin, pathname);\n  return addDatabaseNamespace(withPath, namespace);\n}\n\n/**\n * Get the URL to view data in the database or database emulator.\n *  - Prod: Firebase Console URL\n *  - Emulator: Localhost URL to a `.json` endpoint.\n */\nexport function getDatabaseViewDataUrl(\n  origin: string,\n  project: string,\n  namespace: string,\n  pathname: string\n): string {\n  const urlObj = new url.URL(origin);\n  if (urlObj.hostname.includes(\"firebaseio\") || urlObj.hostname.includes(\"firebasedatabase\")) {\n    return consoleUrl(project, `/database/${namespace}/data${pathname}`);\n  }\n  // TODO(samstern): View in Emulator UI\n  return getDatabaseUrl(origin, namespace, pathname + \".json\");\n}\n\n/**\n * Add the namespace to a database or database emulator URL.\n *  - Prod: Add a subdomain.\n *  - Emulator: Add `?ns=` parameter.\n */\nexport function addDatabaseNamespace(origin: string, namespace: string): string {\n  const urlObj = new url.URL(origin);\n  if (urlObj.hostname.includes(namespace)) {\n    return urlObj.href;\n  }\n  if (urlObj.hostname.includes(\"firebaseio\") || urlObj.hostname.includes(\"firebasedatabase\")) {\n    return addSubdomain(origin, namespace);\n  }\n  urlObj.searchParams.set(\"ns\", namespace);\n  return urlObj.href;\n}\n\n/**\n * Add a subdomain to the specified HTTP origin.\n * (e.g. https://example.com -> https://sub.example.com)\n */\nexport function addSubdomain(origin: string, subdomain: string): string {\n  return origin.replace(\"//\", `//${subdomain}.`);\n}\n\n/**\n * Log an info statement with a green checkmark at the start of the line.\n */\nexport function logSuccess(\n  message: string,\n  type: LogLevel = \"info\",\n  data: LogDataOrUndefined = undefined\n): void {\n  logger[type](clc.green(clc.bold(`${SUCCESS_CHAR} `)), message, data);\n}\n\n/**\n * Log an info statement with a green checkmark at the start of the line.\n */\nexport function logLabeledSuccess(\n  label: string,\n  message: string,\n  type: LogLevel = \"info\",\n  data: LogDataOrUndefined = undefined\n): void {\n  logger[type](clc.green(clc.bold(`${SUCCESS_CHAR}  ${label}:`)), message, data);\n}\n\n/**\n * Log an info statement with a gray bullet at the start of the line.\n */\nexport function logBullet(\n  message: string,\n  type: LogLevel = \"info\",\n  data: LogDataOrUndefined = undefined\n): void {\n  logger[type](clc.cyan(clc.bold(\"i \")), message, data);\n}\n\n/**\n * Log an info statement with a gray bullet at the start of the line.\n */\nexport function logLabeledBullet(\n  label: string,\n  message: string,\n  type: LogLevel = \"info\",\n  data: LogDataOrUndefined = undefined\n): void {\n  logger[type](clc.cyan(clc.bold(`i  ${label}:`)), message, data);\n}\n\n/**\n * Log an info statement with a gray bullet at the start of the line.\n */\nexport function logWarning(\n  message: string,\n  type: LogLevel = \"warn\",\n  data: LogDataOrUndefined = undefined\n): void {\n  logger[type](clc.yellow(clc.bold(`${WARNING_CHAR} `)), message, data);\n}\n\n/**\n * Log an info statement with a gray bullet at the start of the line.\n */\nexport function logLabeledWarning(\n  label: string,\n  message: string,\n  type: LogLevel = \"warn\",\n  data: LogDataOrUndefined = undefined\n): void {\n  logger[type](clc.yellow(clc.bold(`${WARNING_CHAR}  ${label}:`)), message, data);\n}\n\n/**\n * Log an rror statement with a red bullet at the start of the line.\n */\nexport function logLabeledError(\n  label: string,\n  message: string,\n  type: LogLevel = \"error\",\n  data: LogDataOrUndefined = undefined\n): void {\n  logger[type](clc.red(clc.bold(`${ERROR_CHAR}  ${label}:`)), message, data);\n}\n\n/**\n * Return a promise that rejects with a FirebaseError.\n */\nexport function reject(message: string, options?: any): Promise<never> {\n  return Promise.reject(new FirebaseError(message, options));\n}\n\n/** An interface for the result of a successful Promise */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface PromiseFulfilledResult<T = any> {\n  status: \"fulfilled\";\n  value: T;\n}\n\nexport interface PromiseRejectedResult {\n  status: \"rejected\";\n  reason: unknown;\n}\n\nexport type PromiseResult<T> = PromiseFulfilledResult<T> | PromiseRejectedResult;\n\n/**\n * Polyfill for Promise.allSettled\n * TODO: delete once min Node version is 12.9.0 or greater\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function allSettled<T>(promises: Array<Promise<T>>): Promise<Array<PromiseResult<T>>> {\n  if (!promises.length) {\n    return Promise.resolve([]);\n  }\n  return new Promise((resolve) => {\n    let remaining = promises.length;\n    const results: Array<PromiseResult<T>> = [];\n    for (let i = 0; i < promises.length; i++) {\n      // N.B. We use the void operator to silence the linter that we have\n      // a dangling promise (we are, after all, handling all failures).\n      // We resolve the original promise so as not to crash when passed\n      // a non-promise. This is part of the spec.\n      void Promise.resolve(promises[i])\n        .then(\n          (result) => {\n            results[i] = {\n              status: \"fulfilled\",\n              value: result,\n            };\n          },\n          (err) => {\n            results[i] = {\n              status: \"rejected\",\n              reason: err,\n            };\n          }\n        )\n        .then(() => {\n          if (!--remaining) {\n            resolve(results);\n          }\n        });\n    }\n  });\n}\n\n/**\n * Print out an explanatory message if a TTY is detected for how to manage STDIN\n */\nexport function explainStdin(): void {\n  if (IS_WINDOWS) {\n    throw new FirebaseError(\"STDIN input is not available on Windows.\", {\n      exit: 1,\n    });\n  }\n  if (process.stdin.isTTY) {\n    logger.info(clc.bold(\"Note:\"), \"Reading STDIN. Type JSON data and then press Ctrl-D\");\n  }\n}\n\n/**\n * Converts text input to a Readable stream.\n * @param text string to turn into a stream.\n * @return Readable stream, or undefined if text is empty.\n */\nexport function stringToStream(text: string): Readable | undefined {\n  if (!text) {\n    return undefined;\n  }\n  const s = new Readable();\n  s.push(text);\n  s.push(null);\n  return s;\n}\n\n/**\n * Converts a Readable stream into a string.\n * @param s a readable stream.\n * @return a promise resolving to the string'd contents of the stream.\n */\nexport function streamToString(s: NodeJS.ReadableStream): Promise<string> {\n  return new Promise((resolve, reject) => {\n    let b = \"\";\n    s.on(\"error\", reject);\n    s.on(\"data\", (d) => (b += `${d}`));\n    s.once(\"end\", () => resolve(b));\n  });\n}\n\n/**\n * Sets the active project alias or id in the specified directory.\n */\nexport function makeActiveProject(projectDir: string, newActive?: string): void {\n  const activeProjects = configstore.get(\"activeProjects\") || {};\n  if (newActive) {\n    activeProjects[projectDir] = newActive;\n  } else {\n    _.unset(activeProjects, projectDir);\n  }\n  configstore.set(\"activeProjects\", activeProjects);\n}\n\n/**\n * Creates API endpoint string, e.g. /v1/projects/pid/cloudfunctions\n */\nexport function endpoint(parts: string[]): string {\n  return `/${parts.join(\"/\")}`;\n}\n\n/**\n * Gets the event provider name for a Cloud Function from the trigger's\n * eventType string.\n */\nexport function getFunctionsEventProvider(eventType: string): string {\n  // Legacy event types:\n  const parts = eventType.split(\"/\");\n  if (parts.length > 1) {\n    const provider = last(parts[1].split(\".\"));\n    return _.capitalize(provider);\n  }\n  // New event types:\n  if (/google.pubsub/.exec(eventType)) {\n    return \"PubSub\";\n  } else if (/google.storage/.exec(eventType)) {\n    return \"Storage\";\n  } else if (/google.analytics/.exec(eventType)) {\n    return \"Analytics\";\n  } else if (/google.firebase.database/.exec(eventType)) {\n    return \"Database\";\n  } else if (/google.firebase.auth/.exec(eventType)) {\n    return \"Auth\";\n  } else if (/google.firebase.crashlytics/.exec(eventType)) {\n    return \"Crashlytics\";\n  } else if (/google.firestore/.exec(eventType)) {\n    return \"Firestore\";\n  }\n  return _.capitalize(eventType.split(\".\")[1]);\n}\n\nexport interface SettledPromiseResolved {\n  state: \"fulfilled\";\n  value: any;\n}\n\nexport interface SettledPromiseRejected {\n  state: \"rejected\";\n  reason: Error;\n}\n\nexport type SettledPromise = SettledPromiseResolved | SettledPromiseRejected;\n\n/**\n * Returns a single Promise that is resolved when all the given promises have\n * either resolved or rejected.\n */\nexport function promiseAllSettled(promises: Array<Promise<any>>): Promise<SettledPromise[]> {\n  const wrappedPromises = promises.map(async (p) => {\n    try {\n      const val = await Promise.resolve(p);\n      return { state: \"fulfilled\", value: val } as SettledPromiseResolved;\n    } catch (err: any) {\n      return { state: \"rejected\", reason: err } as SettledPromiseRejected;\n    }\n  });\n  return Promise.all(wrappedPromises);\n}\n\n/**\n * Runs a given function (that returns a Promise) repeatedly while the given\n * sync check returns false. Resolves with the value that passed the check.\n */\nexport async function promiseWhile<T>(\n  action: () => Promise<T>,\n  check: (value: T) => boolean,\n  interval = 2500\n): Promise<T> {\n  return new Promise<T>((resolve, promiseReject) => {\n    const run = async () => {\n      try {\n        const res = await action();\n        if (check(res)) {\n          return resolve(res);\n        }\n        setTimeout(run, interval);\n      } catch (err: any) {\n        return promiseReject(err);\n      }\n    };\n    run();\n  });\n}\n\n/**\n * Return a promise that rejects after timeoutMs but otherwise behave the same.\n * @param timeoutMs the time in milliseconds before forced rejection\n * @param promise the original promise\n * @return a promise wrapping the original promise with rejection on timeout\n */\nexport function withTimeout<T>(timeoutMs: number, promise: Promise<T>): Promise<T> {\n  return new Promise<T>((resolve, reject) => {\n    const timeout = setTimeout(() => reject(new Error(\"Timed out.\")), timeoutMs);\n    promise.then(\n      (value) => {\n        clearTimeout(timeout);\n        resolve(value);\n      },\n      (err) => {\n        clearTimeout(timeout);\n        reject(err);\n      }\n    );\n  });\n}\n\n/**\n * Resolves all Promises at every key in the given object. If a value is not a\n * Promise, it is returned as-is.\n */\nexport async function promiseProps(obj: any): Promise<any> {\n  const resultObj: any = {};\n  const promises = Object.keys(obj).map(async (key) => {\n    const r = await Promise.resolve(obj[key]);\n    resultObj[key] = r;\n  });\n  return Promise.all(promises).then(() => resultObj);\n}\n\n/**\n * Attempts to call JSON.stringify on an object, if it throws return the original value\n * @param value\n */\nexport function tryStringify(value: any) {\n  if (typeof value === \"string\") {\n    return value;\n  }\n\n  try {\n    return JSON.stringify(value);\n  } catch {\n    return value;\n  }\n}\n\n/**\n * Attempts to call JSON.parse on an object, if it throws return the original value\n * @param value\n */\nexport function tryParse(value: any) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n\n  try {\n    return JSON.parse(value);\n  } catch {\n    return value;\n  }\n}\n\n/**\n *\n */\nexport function setupLoggers() {\n  if (process.env.DEBUG) {\n    logger.add(\n      new winston.transports.Console({\n        level: \"debug\",\n        format: winston.format.printf((info) => {\n          const segments = [info.message, ...(info[SPLAT] || [])].map(tryStringify);\n          return `${stripAnsi(segments.join(\" \"))}`;\n        }),\n      })\n    );\n  } else if (process.env.IS_FIREBASE_CLI) {\n    logger.add(\n      new winston.transports.Console({\n        level: \"info\",\n        format: winston.format.printf((info) =>\n          [info.message, ...(info[SPLAT] || [])]\n            .filter((chunk) => typeof chunk === \"string\")\n            .join(\" \")\n        ),\n      })\n    );\n  }\n}\n\n/**\n * Runs a given function inside a spinner with a message\n */\nexport async function promiseWithSpinner<T>(action: () => Promise<T>, message: string): Promise<T> {\n  const spinner = ora(message).start();\n  let data;\n  try {\n    data = await action();\n    spinner.succeed();\n  } catch (err: any) {\n    spinner.fail();\n    throw err;\n  }\n\n  return data;\n}\n\n/**\n * Return a \"destroy\" function for a Node.js HTTP server. MUST be called on\n * server creation (e.g. right after `.listen`), BEFORE any connections.\n *\n * Inspired by https://github.com/isaacs/server-destroy/blob/master/index.js\n *\n * @return a function that destroys all connections and closes the server\n */\nexport function createDestroyer(server: http.Server): () => Promise<void> {\n  const connections = new Set<Socket>();\n\n  server.on(\"connection\", (conn) => {\n    connections.add(conn);\n    conn.once(\"close\", () => connections.delete(conn));\n  });\n\n  // Make calling destroyer again just noop but return the same promise.\n  let destroyPromise: Promise<void> | undefined = undefined;\n  return function destroyer() {\n    if (!destroyPromise) {\n      destroyPromise = new Promise((resolve, reject) => {\n        server.close((err) => {\n          if (err) return reject(err);\n          resolve();\n        });\n        connections.forEach((socket) => socket.destroy());\n      });\n    }\n    return destroyPromise;\n  };\n}\n\n/**\n * Returns the given date formatted as `YYYY-mm-dd HH:mm:ss`.\n * @param d the date to format.\n * @return the formatted date.\n */\nexport function datetimeString(d: Date): string {\n  const day = `${d.getFullYear()}-${(d.getMonth() + 1).toString().padStart(2, \"0\")}-${d\n    .getDate()\n    .toString()\n    .padStart(2, \"0\")}`;\n  const time = `${d.getHours().toString().padStart(2, \"0\")}:${d\n    .getMinutes()\n    .toString()\n    .padStart(2, \"0\")}:${d.getSeconds().toString().padStart(2, \"0\")}`;\n  return `${day} ${time}`;\n}\n\n/**\n * Indicates whether the end-user is running the CLI from a cloud-based environment.\n */\nexport function isCloudEnvironment() {\n  return !!process.env.CODESPACES || !!process.env.GOOGLE_CLOUD_WORKSTATIONS;\n}\n\n/**\n * Indicates whether or not this process is likely to be running in WSL.\n * @return true if we're likely in WSL, false otherwise\n */\nexport function isRunningInWSL(): boolean {\n  return !!process.env.WSL_DISTRO_NAME;\n}\n\n/**\n * Generates a date that is 30 days from Date.now()\n */\nexport function thirtyDaysFromNow(): Date {\n  return new Date(Date.now() + THIRTY_DAYS_IN_MILLISECONDS);\n}\n\n/**\n * See:\n * https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#assertion-functions\n */\nexport function assertDefined<T>(val: T, message?: string): asserts val is NonNullable<T> {\n  if (val === undefined || val === null) {\n    throw new AssertionError({\n      message: message || `expected value to be defined but got \"${val}\"`,\n    });\n  }\n}\n\n/**\n *\n */\nexport function assertIsString(val: any, message?: string): asserts val is string {\n  if (typeof val !== \"string\") {\n    throw new AssertionError({\n      message: message || `expected \"string\" but got \"${typeof val}\"`,\n    });\n  }\n}\n\n/**\n *\n */\nexport function assertIsNumber(val: any, message?: string): asserts val is number {\n  if (typeof val !== \"number\") {\n    throw new AssertionError({\n      message: message || `expected \"number\" but got \"${typeof val}\"`,\n    });\n  }\n}\n\n/**\n *\n */\nexport function assertIsStringOrUndefined(\n  val: any,\n  message?: string\n): asserts val is string | undefined {\n  if (!(val === undefined || typeof val === \"string\")) {\n    throw new AssertionError({\n      message: message || `expected \"string\" or \"undefined\" but got \"${typeof val}\"`,\n    });\n  }\n}\n\n/**\n * Polyfill for groupBy.\n */\nexport function groupBy<T, K extends string | number | symbol>(\n  arr: T[],\n  f: (item: T) => K\n): Record<K, T[]> {\n  return arr.reduce((result, item) => {\n    const key = f(item);\n    if (result[key]) {\n      result[key].push(item);\n    } else {\n      result[key] = [item];\n    }\n    return result;\n  }, {} as Record<K, T[]>);\n}\n\nfunction cloneArray<T>(arr: T[]): T[] {\n  return arr.map((e) => cloneDeep(e));\n}\n\nfunction cloneObject<T extends Record<string, unknown>>(obj: T): T {\n  const clone: Record<string, unknown> = {};\n  for (const [k, v] of Object.entries(obj)) {\n    clone[k] = cloneDeep(v);\n  }\n  return clone as T;\n}\n\n/**\n * replacement for lodash cloneDeep that preserves type.\n */\n// TODO: replace with builtin once Node 18 becomes the min version.\nexport function cloneDeep<T>(obj: T): T {\n  if (typeof obj !== \"object\" || !obj) {\n    return obj;\n  }\n  if (obj instanceof RegExp) {\n    return RegExp(obj, obj.flags) as typeof obj;\n  }\n  if (obj instanceof Date) {\n    return new Date(obj) as typeof obj;\n  }\n  if (Array.isArray(obj)) {\n    return cloneArray(obj) as typeof obj;\n  }\n  if (obj instanceof Map) {\n    return new Map(obj.entries()) as typeof obj;\n  }\n  return cloneObject(obj as Record<string, unknown>) as typeof obj;\n}\n\n/**\n * Returns the last element in the array, or undefined if no array is passed or\n * the array is empty.\n */\nexport function last<T>(arr?: T[]): T {\n  // The type system should never allow this, so return something that violates\n  // the type system when passing in something that violates the type system.\n  if (!Array.isArray(arr)) {\n    return undefined as unknown as T;\n  }\n  return arr[arr.length - 1];\n}\n\n/**\n * Options for debounce.\n */\ntype DebounceOptions = {\n  leading?: boolean;\n};\n\n/**\n * Returns a function that delays invoking `fn` until `delay` ms have\n * passed since the last time `fn` was invoked.\n */\nexport function debounce<T>(\n  fn: (...args: T[]) => void,\n  delay: number,\n  { leading }: DebounceOptions = {}\n): (...args: T[]) => void {\n  let timer: NodeJS.Timeout;\n  return (...args) => {\n    if (!timer && leading) {\n      fn(...args);\n    }\n    clearTimeout(timer);\n    timer = setTimeout(() => fn(...args), delay);\n  };\n}\n\n/**\n * Returns a random number between min and max, inclusive.\n */\nexport function randomInt(min: number, max: number): number {\n  min = Math.floor(min);\n  max = Math.ceil(max) + 1;\n  return Math.floor(Math.random() * (max - min) + min);\n}\n\n/**\n * Return a connectable hostname, replacing wildcard 0.0.0.0 or :: with loopback\n * addresses 127.0.0.1 / ::1 correspondingly. See below for why this is needed:\n * https://github.com/firebase/firebase-tools-ui/issues/286\n *\n * This assumes that the consumer (i.e. client SDK, etc.) is located on the same\n * device as the Emulator hub (i.e. CLI), which may not be true on multi-device\n * setups, etc. In that case, the customer can work around this by specifying a\n * non-wildcard IP address (like the IP address on LAN, if accessing via LAN).\n */\nexport function connectableHostname(hostname: string): string {\n  if (hostname === \"0.0.0.0\") {\n    hostname = \"127.0.0.1\";\n  } else if (hostname === \"::\" /* unquoted IPv6 wildcard */) {\n    hostname = \"::1\";\n  } else if (hostname === \"[::]\" /* quoted IPv6 wildcard */) {\n    hostname = \"[::1]\";\n  }\n  return hostname;\n}\n","module.exports = require(\"colorette\");","module.exports = require(\"lodash\");","module.exports = require(\"strip-ansi\");","module.exports = require(\"winston\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"vscode\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"form-data\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"jsonwebtoken\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"open\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"portfinder\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"proxy-agent\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"retry\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"abort-controller\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"node-fetch\");","import { AbortSignal } from \"abort-controller\";\nimport { URL, URLSearchParams } from \"url\";\nimport { Readable } from \"stream\";\nimport * as ProxyAgent from \"proxy-agent\";\nimport * as retry from \"retry\";\nimport AbortController from \"abort-controller\";\nimport fetch, { HeadersInit, Response, RequestInit, Headers } from \"node-fetch\";\nimport util from \"util\";\n\nimport * as auth from \"./auth\";\nimport { FirebaseError } from \"./error\";\nimport { logger } from \"./logger\";\nimport { responseToError } from \"./responseToError\";\nimport * as FormData from \"form-data\";\n\n// Using import would require resolveJsonModule, which seems to break the\n// build/output format.\nconst pkg = require(\"../package.json\");\nconst CLI_VERSION: string = pkg.version;\n\nconst GOOG_QUOTA_USER = \"x-goog-quota-user\";\n\nexport type HttpMethod = \"GET\" | \"PUT\" | \"POST\" | \"DELETE\" | \"PATCH\";\n\ninterface BaseRequestOptions<T> extends VerbOptions {\n  method: HttpMethod;\n  path: string;\n  body?: T | string | NodeJS.ReadableStream;\n  responseType?: \"json\" | \"stream\" | \"xml\";\n  redirect?: \"error\" | \"follow\" | \"manual\";\n  compress?: boolean;\n}\n\ninterface RequestOptionsWithSignal<T> extends BaseRequestOptions<T> {\n  // Signal is used to cancel a request. Cannot be used with `timeout`.\n  signal?: AbortSignal;\n  timeout?: never;\n}\n\ninterface RequestOptionsWithTimeout<T> extends BaseRequestOptions<T> {\n  signal?: never;\n  // Timeout, in ms. 0 is no timeout. Cannot be used with `signal`.\n  timeout?: number;\n}\n\ntype RequestOptions<T> = RequestOptionsWithSignal<T> | RequestOptionsWithTimeout<T>;\n\ninterface VerbOptions {\n  method?: HttpMethod;\n  headers?: HeadersInit;\n  queryParams?: URLSearchParams | { [key: string]: string | number };\n}\n\ninterface ClientHandlingOptions {\n  skipLog?: {\n    queryParams?: boolean;\n    body?: boolean;\n    resBody?: boolean;\n  };\n  resolveOnHTTPError?: boolean;\n  /** Codes on which to retry. Defaults to none. */\n  retryCodes?: number[];\n  /** Number of retries. Defaults to 0 (one attempt) with no retryCodes, 1 with retryCodes. */\n  retries?: number;\n  /** Minimum timeout between retries. Defaults to 1s. */\n  retryMinTimeout?: number;\n  /** Maximum timeout between retries. Defaults to 5s. */\n  retryMaxTimeout?: number;\n}\n\nexport type ClientRequestOptions<T> = RequestOptions<T> & ClientVerbOptions;\n\ninterface BaseInternalClientRequestOptions {\n  headers?: Headers;\n}\n\ntype InternalClientRequestOptions<T> = BaseInternalClientRequestOptions & ClientRequestOptions<T>;\n\nexport type ClientVerbOptions = VerbOptions & ClientHandlingOptions;\n\nexport type ClientResponse<T> = {\n  status: number;\n  response: Response;\n  body: T;\n};\n\nlet accessToken = \"\";\nlet refreshToken = \"\";\n\n/**\n * Sets the refresh token.\n * @param token refresh token.\n */\nexport function setRefreshToken(token = \"\"): void {\n  refreshToken = token;\n}\n\n/**\n * Sets the access token.\n * @param token access token.\n */\nexport function setAccessToken(token = \"\"): void {\n  accessToken = token;\n}\n\nfunction proxyURIFromEnv(): string | undefined {\n  return (\n    process.env.HTTPS_PROXY ||\n    process.env.https_proxy ||\n    process.env.HTTP_PROXY ||\n    process.env.http_proxy ||\n    undefined\n  );\n}\n\nexport type ClientOptions = {\n  urlPrefix: string;\n  apiVersion?: string;\n  auth?: boolean;\n  proxy?: string;\n};\n\nexport class Client {\n  constructor(private opts: ClientOptions) {\n    if (this.opts.auth === undefined) {\n      this.opts.auth = true;\n    }\n    if (this.opts.urlPrefix.endsWith(\"/\")) {\n      this.opts.urlPrefix = this.opts.urlPrefix.substring(0, this.opts.urlPrefix.length - 1);\n    }\n  }\n\n  get<ResT>(path: string, options: ClientVerbOptions = {}): Promise<ClientResponse<ResT>> {\n    const reqOptions: ClientRequestOptions<unknown> = Object.assign(options, {\n      method: \"GET\",\n      path,\n    });\n    return this.request<unknown, ResT>(reqOptions);\n  }\n\n  post<ReqT, ResT>(\n    path: string,\n    json?: ReqT,\n    options: ClientVerbOptions = {}\n  ): Promise<ClientResponse<ResT>> {\n    const reqOptions: ClientRequestOptions<ReqT> = Object.assign(options, {\n      method: \"POST\",\n      path,\n      body: json,\n    });\n    return this.request<ReqT, ResT>(reqOptions);\n  }\n\n  patch<ReqT, ResT>(\n    path: string,\n    json?: ReqT,\n    options: ClientVerbOptions = {}\n  ): Promise<ClientResponse<ResT>> {\n    const reqOptions: ClientRequestOptions<ReqT> = Object.assign(options, {\n      method: \"PATCH\",\n      path,\n      body: json,\n    });\n    return this.request<ReqT, ResT>(reqOptions);\n  }\n\n  put<ReqT, ResT>(\n    path: string,\n    json?: ReqT,\n    options: ClientVerbOptions = {}\n  ): Promise<ClientResponse<ResT>> {\n    const reqOptions: ClientRequestOptions<ReqT> = Object.assign(options, {\n      method: \"PUT\",\n      path,\n      body: json,\n    });\n    return this.request<ReqT, ResT>(reqOptions);\n  }\n\n  delete<ResT>(path: string, options: ClientVerbOptions = {}): Promise<ClientResponse<ResT>> {\n    const reqOptions: ClientRequestOptions<unknown> = Object.assign(options, {\n      method: \"DELETE\",\n      path,\n    });\n    return this.request<unknown, ResT>(reqOptions);\n  }\n\n  /**\n   * Makes a request as specified by the options.\n   * By default, this will:\n   *   - use content-type: application/json\n   *   - assume the HTTP GET method\n   *\n   * @example\n   * const res = apiv2.request<ResourceType>({\n   *   method: \"POST\",\n   *   path: \"/some/resource\",\n   *   queryParams: { updateMask: \"key\" },\n   *   json: { name: \"resource-name\", key: \"updated-value\" }\n   * });\n   * // typeof res.body === ResourceType\n   * @param reqOptions request options.\n   * @return the response.\n   */\n  async request<ReqT, ResT>(reqOptions: ClientRequestOptions<ReqT>): Promise<ClientResponse<ResT>> {\n    // All requests default to JSON content types.\n    if (!reqOptions.responseType) {\n      reqOptions.responseType = \"json\";\n    }\n\n    // TODO(bkendall): stream + !resolveOnHTTPError makes for difficult handling.\n    //   Figure out if there's a better way to handle streamed >=400 responses.\n    if (reqOptions.responseType === \"stream\" && !reqOptions.resolveOnHTTPError) {\n      throw new FirebaseError(\n        \"apiv2 will not handle HTTP errors while streaming and you must set `resolveOnHTTPError` and check for res.status >= 400 on your own\",\n        { exit: 2 }\n      );\n    }\n\n    let internalReqOptions: InternalClientRequestOptions<ReqT> = Object.assign(reqOptions, {\n      headers: new Headers(reqOptions.headers),\n    });\n\n    internalReqOptions = this.addRequestHeaders(internalReqOptions);\n\n    if (this.opts.auth) {\n      internalReqOptions = await this.addAuthHeader(internalReqOptions);\n    }\n    try {\n      return await this.doRequest<ReqT, ResT>(internalReqOptions);\n    } catch (thrown: any) {\n      if (thrown instanceof FirebaseError) {\n        throw thrown;\n      }\n      // Though it should never happen in practice, a non-Error type can be thrown\n      let err: Error;\n      if (thrown instanceof Error) {\n        err = thrown;\n      } else {\n        err = new Error(thrown);\n      }\n      throw new FirebaseError(`Failed to make request: ${err.message}`, { original: err });\n    }\n  }\n\n  private addRequestHeaders<T>(\n    reqOptions: InternalClientRequestOptions<T>\n  ): InternalClientRequestOptions<T> {\n    if (!reqOptions.headers) {\n      reqOptions.headers = new Headers();\n    }\n    reqOptions.headers.set(\"Connection\", \"keep-alive\");\n    if (!reqOptions.headers.has(\"User-Agent\")) {\n      reqOptions.headers.set(\"User-Agent\", `FirebaseCLI/${CLI_VERSION}`);\n    }\n    reqOptions.headers.set(\"X-Client-Version\", `FirebaseCLI/${CLI_VERSION}`);\n    if (!reqOptions.headers.has(\"Content-Type\")) {\n      if (reqOptions.responseType === \"json\") {\n        reqOptions.headers.set(\"Content-Type\", \"application/json\");\n      }\n    }\n    return reqOptions;\n  }\n\n  private async addAuthHeader<T>(\n    reqOptions: InternalClientRequestOptions<T>\n  ): Promise<InternalClientRequestOptions<T>> {\n    if (!reqOptions.headers) {\n      reqOptions.headers = new Headers();\n    }\n    let token: string;\n    if (isLocalInsecureRequest(this.opts.urlPrefix)) {\n      token = \"owner\";\n    } else {\n      token = await this.getAccessToken();\n    }\n    reqOptions.headers.set(\"Authorization\", `Bearer ${token}`);\n    return reqOptions;\n  }\n\n  private async getAccessToken(): Promise<string> {\n    // Runtime fetch of Auth singleton to prevent circular module dependencies\n    if (accessToken) {\n      return accessToken;\n    }\n    // TODO: remove the as any once auth.js is migrated to auth.ts\n    interface AccessToken {\n      access_token: string;\n    }\n    const data = (await auth.getAccessToken(refreshToken, [])) as AccessToken;\n    return data.access_token;\n  }\n\n  private requestURL(options: InternalClientRequestOptions<unknown>): string {\n    const versionPath = this.opts.apiVersion ? `/${this.opts.apiVersion}` : \"\";\n    return `${this.opts.urlPrefix}${versionPath}${options.path}`;\n  }\n\n  private async doRequest<ReqT, ResT>(\n    options: InternalClientRequestOptions<ReqT>\n  ): Promise<ClientResponse<ResT>> {\n    if (!options.path.startsWith(\"/\")) {\n      options.path = \"/\" + options.path;\n    }\n\n    let fetchURL = this.requestURL(options);\n    if (options.queryParams) {\n      if (!(options.queryParams instanceof URLSearchParams)) {\n        const sp = new URLSearchParams();\n        for (const key of Object.keys(options.queryParams)) {\n          const value = options.queryParams[key];\n          sp.append(key, `${value}`);\n        }\n        options.queryParams = sp;\n      }\n      const queryString = options.queryParams.toString();\n      if (queryString) {\n        fetchURL += `?${queryString}`;\n      }\n    }\n\n    const fetchOptions: RequestInit = {\n      headers: options.headers,\n      method: options.method,\n      redirect: options.redirect,\n      compress: options.compress,\n    };\n\n    if (this.opts.proxy) {\n      fetchOptions.agent = new ProxyAgent(this.opts.proxy);\n    }\n    const envProxy = proxyURIFromEnv();\n    if (envProxy) {\n      fetchOptions.agent = new ProxyAgent(envProxy);\n    }\n\n    if (options.signal) {\n      fetchOptions.signal = options.signal;\n    }\n\n    let reqTimeout: NodeJS.Timeout | undefined;\n    if (options.timeout) {\n      const controller = new AbortController();\n      reqTimeout = setTimeout(() => {\n        controller.abort();\n      }, options.timeout);\n      fetchOptions.signal = controller.signal;\n    }\n\n    if (typeof options.body === \"string\" || isStream(options.body)) {\n      fetchOptions.body = options.body;\n    } else if (options.body !== undefined) {\n      fetchOptions.body = JSON.stringify(options.body);\n    }\n\n    // TODO(bkendall): Refactor this to use Throttler _or_ refactor Throttle to use `retry`.\n    const operationOptions: retry.OperationOptions = {\n      retries: options.retryCodes?.length ? 1 : 2,\n      minTimeout: 1 * 1000,\n      maxTimeout: 5 * 1000,\n    };\n    if (typeof options.retries === \"number\") {\n      operationOptions.retries = options.retries;\n    }\n    if (typeof options.retryMinTimeout === \"number\") {\n      operationOptions.minTimeout = options.retryMinTimeout;\n    }\n    if (typeof options.retryMaxTimeout === \"number\") {\n      operationOptions.maxTimeout = options.retryMaxTimeout;\n    }\n    const operation = retry.operation(operationOptions);\n\n    return await new Promise<ClientResponse<ResT>>((resolve, reject) => {\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      operation.attempt(async (currentAttempt): Promise<void> => {\n        let res: Response;\n        let body: ResT;\n        try {\n          if (currentAttempt > 1) {\n            logger.debug(\n              `*** [apiv2] Attempting the request again. Attempt number ${currentAttempt}`\n            );\n          }\n          this.logRequest(options);\n\n          try {\n            res = await fetch(fetchURL, fetchOptions);\n          } catch (thrown: any) {\n            const err = thrown instanceof Error ? thrown : new Error(thrown);\n            const isAbortError = err.name.includes(\"AbortError\");\n            if (isAbortError) {\n              throw new FirebaseError(`Timeout reached making request to ${fetchURL}`, {\n                original: err,\n              });\n            }\n            throw new FirebaseError(`Failed to make request to ${fetchURL}`, { original: err });\n          } finally {\n            // If we succeed or failed, clear the timeout.\n            if (reqTimeout) {\n              clearTimeout(reqTimeout);\n            }\n          }\n\n          if (options.responseType === \"json\") {\n            const text = await res.text();\n            // Some responses, such as 204 and occasionally 202s don't have\n            // any content. We can't just rely on response code (202 may have conent)\n            // and unfortuantely res.length is unreliable (many requests return zero).\n            if (!text.length) {\n              body = undefined as unknown as ResT;\n            } else {\n              try {\n                body = JSON.parse(text) as ResT;\n              } catch (err: unknown) {\n                // JSON-parse errors are useless. Log the response for better debugging.\n                this.logResponse(res, text, options);\n                throw new FirebaseError(`Unable to parse JSON: ${err}`);\n              }\n            }\n          } else if (options.responseType === \"xml\") {\n            body = (await res.text()) as unknown as ResT;\n          } else if (options.responseType === \"stream\") {\n            body = res.body as unknown as ResT;\n          } else {\n            throw new FirebaseError(`Unable to interpret response. Please set responseType.`, {\n              exit: 2,\n            });\n          }\n        } catch (err: unknown) {\n          return err instanceof FirebaseError ? reject(err) : reject(new FirebaseError(`${err}`));\n        }\n\n        this.logResponse(res, body, options);\n\n        if (res.status >= 400) {\n          if (options.retryCodes?.includes(res.status)) {\n            const err = responseToError({ statusCode: res.status }, body) || undefined;\n            if (operation.retry(err)) {\n              return;\n            }\n          }\n          if (!options.resolveOnHTTPError) {\n            return reject(responseToError({ statusCode: res.status }, body));\n          }\n        }\n\n        resolve({\n          status: res.status,\n          response: res,\n          body,\n        });\n      });\n    });\n  }\n\n  private logRequest(options: InternalClientRequestOptions<unknown>): void {\n    let queryParamsLog = \"[none]\";\n    if (options.queryParams) {\n      queryParamsLog = \"[omitted]\";\n      if (!options.skipLog?.queryParams) {\n        queryParamsLog =\n          options.queryParams instanceof URLSearchParams\n            ? options.queryParams.toString()\n            : JSON.stringify(options.queryParams);\n      }\n    }\n    const logURL = this.requestURL(options);\n    logger.debug(`>>> [apiv2][query] ${options.method} ${logURL} ${queryParamsLog}`);\n    const headers = options.headers;\n    if (headers && headers.has(GOOG_QUOTA_USER)) {\n      logger.debug(\n        `>>> [apiv2][(partial)header] ${options.method} ${logURL} x-goog-quota-user=${\n          headers.get(GOOG_QUOTA_USER) || \"\"\n        }`\n      );\n    }\n    if (options.body !== undefined) {\n      let logBody = \"[omitted]\";\n      if (!options.skipLog?.body) {\n        logBody = bodyToString(options.body);\n      }\n      logger.debug(`>>> [apiv2][body] ${options.method} ${logURL} ${logBody}`);\n    }\n  }\n\n  private logResponse(\n    res: Response,\n    body: unknown,\n    options: InternalClientRequestOptions<unknown>\n  ): void {\n    const logURL = this.requestURL(options);\n    logger.debug(`<<< [apiv2][status] ${options.method} ${logURL} ${res.status}`);\n    let logBody = \"[omitted]\";\n    if (!options.skipLog?.resBody) {\n      logBody = bodyToString(body);\n    }\n    logger.debug(`<<< [apiv2][body] ${options.method} ${logURL} ${logBody}`);\n  }\n}\n\nfunction isLocalInsecureRequest(urlPrefix: string): boolean {\n  const u = new URL(urlPrefix);\n  return u.protocol === \"http:\";\n}\n\nfunction bodyToString(body: unknown): string {\n  if (isStream(body)) {\n    // Don't attempt to read any stream type, in case the caller needs it.\n    return \"[stream]\";\n  } else {\n    try {\n      return JSON.stringify(body);\n    } catch (_) {\n      return util.inspect(body);\n    }\n  }\n}\n\nfunction isStream(o: unknown): o is NodeJS.ReadableStream {\n  return o instanceof Readable || o instanceof FormData;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"inquirer\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"uuid\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"universal-analytics\");","import fetch from \"node-fetch\";\nimport * as ua from \"universal-analytics\";\nimport { v4 as uuidV4 } from \"uuid\";\nimport { getGlobalDefaultAccount } from \"./auth\";\n\nimport { configstore } from \"./configstore\";\nimport { logger } from \"./logger\";\nconst pkg = require(\"../package.json\");\n\n// The ID identifying the GA4 property for the Emulator Suite only. Should only\n// be used in Emulator UI and emulator-related commands (e.g. emulators:start).\nexport const EMULATOR_GA4_MEASUREMENT_ID =\n  process.env.FIREBASE_EMULATOR_GA4_MEASUREMENT_ID || \"G-KYP2JMPFC0\";\n\nexport function usageEnabled(): boolean {\n  return !!configstore.get(\"usage\");\n}\n\n// The Tracking ID for the Universal Analytics property for all of the CLI\n// including emulator-related commands (double-tracked for historical reasons)\n// but excluding Emulator UI.\n// TODO: Upgrade to GA4 before July 1, 2023. See:\n// https://support.google.com/analytics/answer/11583528\nconst FIREBASE_ANALYTICS_UA = process.env.FIREBASE_ANALYTICS_UA || \"UA-29174744-3\";\n\n// Identifier for the client (UUID) in the CLI UA.\nlet anonId = configstore.get(\"analytics-uuid\");\nif (!anonId) {\n  anonId = uuidV4();\n  configstore.set(\"analytics-uuid\", anonId);\n}\n\nconst visitor = ua(FIREBASE_ANALYTICS_UA, anonId, {\n  strictCidFormat: false,\n  https: true,\n});\n\nvisitor.set(\"cd1\", process.platform); // Platform\nvisitor.set(\"cd2\", process.version); // NodeVersion\nvisitor.set(\"cd3\", process.env.FIREPIT_VERSION || \"none\"); // FirepitVersion\n\nexport function track(action: string, label: string, duration: number = 0): Promise<void> {\n  return new Promise((resolve) => {\n    if (configstore.get(\"tokens\") && usageEnabled()) {\n      visitor.event(\"Firebase CLI \" + pkg.version, action, label, duration).send(() => {\n        // we could handle errors here, but we won't\n        resolve();\n      });\n    } else {\n      resolve();\n    }\n  });\n}\n\nconst EMULATOR_GA4_API_SECRET =\n  process.env.FIREBASE_EMULATOR_GA4_API_SECRET || \"2V_zBYc4TdeoppzDaIu0zw\";\n\n// Prop name length must <= 24 and cannot begin with google_/ga_/firebase_.\n// https://developers.google.com/analytics/devguides/collection/protocol/ga4/reference?client_type=firebase#reserved_parameter_names\nconst EMULATOR_GA4_USER_PROPS = {\n  node_platform: {\n    value: process.platform,\n  },\n  node_version: {\n    value: process.version,\n  },\n  cli_version: {\n    value: pkg.version,\n  },\n  firepit_version: {\n    value: process.env.FIREPIT_VERSION || \"none\",\n  },\n};\n\nexport interface AnalyticsParams {\n  /** The command running right now (param for custom dimension) */\n  command_name?: string;\n\n  /** The emulator related to the event (param for custom dimension) */\n  emulator_name?: string;\n\n  /** The number of times or objects (param for custom metrics) */\n  count?: number;\n\n  /** The elapsed time in milliseconds (e.g. for command runs) (param for custom metrics) */\n  duration?: number;\n\n  /**\n   * One-off params (that may be used for custom params / metrics later).\n   *\n   * Custom parameter names should be in snake_case. (Formal requirement:\n   * length <= 40, alpha-numeric characters and underscores only (*no spaces*),\n   * and must start with an alphabetic character.)\n   *\n   * If the value is a string, it must have length <= 100. For convenience, the\n   * entire paramater is omitted (not sent to GA4) if value is set to undefined.\n   */\n  [key: string]: string | number | undefined;\n}\n\n/**\n * Record an emulator-related event for Analytics.\n *\n * @param eventName the event name in snake_case. (Formal requirement:\n *                  length <= 40, alpha-numeric characters and underscores only\n *                  (*no spaces*), and must start with an alphabetic character)\n * @param params custom and standard parameters attached to the event\n * @returns a Promise fulfilled when the event reaches the server or fails\n *          (never rejects unless `emulatorSession().validateOnly` is set)\n *\n * Note: On performance or latency critical paths, the returned Promise may be\n * safely ignored with the statement `void trackEmulator(...)`.\n */\nexport async function trackEmulator(eventName: string, params?: AnalyticsParams): Promise<void> {\n  const session = emulatorSession();\n  if (!session) {\n    return;\n  }\n\n  // Since there's no concept of foreground / active, we'll just assume users\n  // are constantly engaging with the CLI since Node.js process started. (Yes,\n  // staring at the terminal and waiting for the command to finish also counts.)\n  const oldTotalEngagementSeconds = session.totalEngagementSeconds;\n  session.totalEngagementSeconds = process.uptime();\n\n  // Memorize and set command_name throughout the session.\n  session.commandName = params?.command_name || session.commandName;\n\n  const search = `?api_secret=${EMULATOR_GA4_API_SECRET}&measurement_id=${session.measurementId}`;\n  const validate = session.validateOnly ? \"debug/\" : \"\";\n  const url = `https://www.google-analytics.com/${validate}mp/collect${search}`;\n  const body = {\n    // Get timestamp in millis and append '000' to get micros as string.\n    // Not using multiplication due to JS number precision limit.\n    timestamp_micros: `${Date.now()}000`,\n    client_id: session.clientId,\n    user_properties: {\n      ...EMULATOR_GA4_USER_PROPS,\n      java_major_version: session.javaMajorVersion\n        ? { value: session.javaMajorVersion }\n        : undefined,\n    },\n    validationBehavior: session.validateOnly ? \"ENFORCE_RECOMMENDATIONS\" : undefined,\n    events: [\n      {\n        name: eventName,\n        params: {\n          session_id: session.sessionId,\n\n          // engagement_time_msec and session_id must be set for the activity\n          // to display in standard reports like Realtime.\n          // https://developers.google.com/analytics/devguides/collection/protocol/ga4/sending-events?client_type=gtag#optional_parameters_for_reports\n\n          // https://support.google.com/analytics/answer/11109416?hl=en\n          // Additional engagement time since last event, in microseconds.\n          engagement_time_msec: (session.totalEngagementSeconds - oldTotalEngagementSeconds)\n            .toFixed(3)\n            .replace(\".\", \"\")\n            .replace(/^0+/, \"\"), // trim leading zeros\n\n          // https://support.google.com/analytics/answer/7201382?hl=en\n          // To turn debug mode off, `debug_mode` must be left out not `false`.\n          debug_mode: session.debugMode ? true : undefined,\n          command_name: session.commandName,\n          ...params,\n        },\n      },\n    ],\n  };\n  if (session.validateOnly) {\n    logger.info(`Sending Analytics for event ${eventName}`, params, body);\n  }\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"content-type\": \"application/json;charset=UTF-8\",\n      },\n      body: JSON.stringify(body),\n    });\n    if (session.validateOnly) {\n      // If the validation endpoint is used, response may contain errors.\n      if (!response.ok) {\n        logger.warn(`Analytics validation HTTP error: ${response.status}`);\n      }\n      const respBody = await response.text();\n      logger.info(`Analytics validation result: ${respBody}`);\n    }\n    // response.ok / response.status intentionally ignored, see comment below.\n  } catch (e: unknown) {\n    if (session.validateOnly) {\n      throw e;\n    }\n    // Otherwise, we will ignore the status / error for these reasons:\n    // * the endpoint always return 2xx even if request is malformed\n    // * non-2xx requests should _not_ be retried according to documentation\n    // * analytics is non-critical and should not fail other operations.\n    // https://developers.google.com/analytics/devguides/collection/protocol/ga4/reference?client_type=gtag#response_codes\n    return;\n  }\n}\n\nexport interface AnalyticsSession {\n  measurementId: string;\n  clientId: string;\n\n  // https://support.google.com/analytics/answer/9191807\n  // We treat each CLI invocation as a different session, including any CLI\n  // events and Emulator UI interactions.\n  sessionId: string;\n  totalEngagementSeconds: number;\n\n  // Whether the events sent should be tagged so that they are shown in GA Debug\n  // View in real time (for Googler to debug) and excluded from reports.\n  debugMode: boolean;\n\n  // Whether to validate events format instead of collecting them. Should only\n  // be used to debug the Firebase CLI / Emulator UI itself regarding issues\n  // with Analytics. To enable, set the env var FIREBASE_CLI_MP_VALIDATE.\n  // In the CLI, this is implemented by sending events to the GA4 measurement\n  // validation API (which does not persist events) and printing the response.\n  validateOnly: boolean;\n\n  // The Java major version, if known. Will be attached to subsequent events.\n  javaMajorVersion?: number;\n\n  commandName?: string;\n}\n\nexport function emulatorSession(): AnalyticsSession | undefined {\n  const validateOnly = !!process.env.FIREBASE_CLI_MP_VALIDATE;\n  if (!usageEnabled()) {\n    if (validateOnly) {\n      logger.warn(\"Google Analytics is DISABLED. To enable, (re)login and opt in to collection.\");\n    }\n    return;\n  }\n  if (!currentEmulatorSession) {\n    let clientId: string | undefined = configstore.get(\"emulator-analytics-clientId\");\n    if (!clientId) {\n      clientId = uuidV4();\n      configstore.set(\"emulator-analytics-clientId\", clientId);\n    }\n\n    currentEmulatorSession = {\n      measurementId: EMULATOR_GA4_MEASUREMENT_ID,\n      clientId,\n\n      // This must be an int64 string, but only ~50 bits are generated here\n      // for simplicity. (AFAICT, they just need to be unique per clientId,\n      // instead of globally. Revisit if that is not the case.)\n      // https://help.analyticsedge.com/article/misunderstood-metrics-sessions-in-google-analytics-4/#:~:text=The%20Session%20ID%20Is%20Not%20Unique\n      sessionId: (Math.random() * Number.MAX_SAFE_INTEGER).toFixed(0),\n      totalEngagementSeconds: 0,\n      debugMode: isDebugMode(),\n      validateOnly,\n    };\n  }\n  return currentEmulatorSession;\n}\n\nlet currentEmulatorSession: AnalyticsSession | undefined = undefined;\n\nfunction isDebugMode(): boolean {\n  const account = getGlobalDefaultAccount();\n  if (account?.user.email.endsWith(\"@google.com\")) {\n    try {\n      require(\"../tsconfig.json\");\n      logger.info(\n        `Using Google Analytics in DEBUG mode. Emulators (+ UI) events will be shown in GA Debug View only.`\n      );\n      return true;\n    } catch {\n      // The file above present in the repo but not packaged to npm. If require\n      // fails, just turn off debug mode since the CLI is not in development.\n    }\n  }\n  return false;\n}\n","// The module 'vscode' contains the VS Code extensibility API\n// Import the module and reference it with the alias vscode in your code below\nimport * as vscode from 'vscode';\n\nimport { getGlobalDefaultAccount } from '../../src/auth';\n\n// This method is called when your extension is activated\n// Your extension is activated the very first time the command is executed\nexport function activate(context: vscode.ExtensionContext) {\n\n\t// Use the console to output diagnostic information (console.log) and errors (console.error)\n\t// This line of code will only be executed once when your extension is activated\n\tconsole.log('Congratulations, your extension \"firebase-vscode\" is now active!');\n\n\t// The command has been defined in the package.json file\n\t// Now provide the implementation of the command with registerCommand\n\t// The commandId parameter must match the command field in package.json\n\tlet disposable = vscode.commands.registerCommand('firebase-vscode.helloWorld', () => {\n\t\t// The code you place here will be executed every time your command is executed\n\t\t// Display a message box to the user\n\t\tconst account = getGlobalDefaultAccount();\n\n\t\tvscode.window.showInformationMessage(`${JSON.stringify(account)}`);\n\t\tvscode.window.showInformationMessage(`User ${account?.user.email || 'none'}`);\n\t});\n\n\tcontext.subscriptions.push(disposable);\n}\n\n// This method is called when your extension is deactivated\nexport function deactivate() {}\n","import * as clc from \"colorette\";\nimport * as FormData from \"form-data\";\nimport * as fs from \"fs\";\nimport * as http from \"http\";\nimport * as jwt from \"jsonwebtoken\";\nimport * as opn from \"open\";\nimport * as path from \"path\";\nimport * as portfinder from \"portfinder\";\nimport * as url from \"url\";\nimport * as util from \"util\";\n\nimport * as apiv2 from \"./apiv2\";\nimport { configstore } from \"./configstore\";\nimport { FirebaseError } from \"./error\";\nimport * as utils from \"./utils\";\nimport { logger } from \"./logger\";\nimport { promptOnce } from \"./prompt\";\nimport * as scopes from \"./scopes\";\nimport { clearCredentials } from \"./defaultCredentials\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { randomBytes, createHash } from \"crypto\";\nimport { track } from \"./track\";\nimport {\n  authOrigin,\n  authProxyOrigin,\n  clientId,\n  clientSecret,\n  githubClientId,\n  githubClientSecret,\n  githubOrigin,\n  googleOrigin,\n} from \"./api\";\n\n// The wire protocol for an access token returned by Google.\n// When we actually refresh from the server we should always have\n// these optional fields, but when a user passes --token we may\n// only have access_token.\nexport interface Tokens {\n  id_token?: string;\n  access_token: string;\n  refresh_token?: string;\n  scopes?: string[];\n}\n\nexport interface User {\n  email: string;\n\n  iss?: string;\n  azp?: string;\n  aud?: string;\n  sub?: number;\n  hd?: string;\n  email_verified?: boolean;\n  at_hash?: string;\n  iat?: number;\n  exp?: number;\n}\n\nexport interface Account {\n  user: User;\n  tokens: Tokens;\n}\n\ninterface TokensWithExpiration extends Tokens {\n  expires_at?: number;\n}\n\ninterface TokensWithTTL extends Tokens {\n  expires_in?: number;\n}\n\ninterface UserCredentials {\n  user: string | User;\n  tokens: TokensWithExpiration;\n  scopes: string[];\n}\n\n// https://docs.github.com/en/developers/apps/authorizing-oauth-apps\ninterface GitHubAuthResponse {\n  access_token: string;\n  scope: string;\n  token_type: string;\n}\n\nportfinder.setBasePort(9005);\n\n/**\n * Get the global default account. Before multi-auth was implemented\n * this was the only account.\n */\nexport function getGlobalDefaultAccount(): Account | undefined {\n  const user = configstore.get(\"user\") as User | undefined;\n  const tokens = configstore.get(\"tokens\") as Tokens | undefined;\n\n  // TODO: Is there ever a case where only User or Tokens is defined\n  //       and we want to accept that?\n  if (!user || !tokens) {\n    return undefined;\n  }\n\n  return {\n    user,\n    tokens,\n  };\n}\n\n/**\n * Get the default account associated with a project directory, or the global default.\n * @param projectDir the Firebase project directory.\n */\nexport function getProjectDefaultAccount(projectDir?: string | null): Account | undefined {\n  if (!projectDir) {\n    return getGlobalDefaultAccount();\n  }\n\n  const activeAccounts = configstore.get(\"activeAccounts\") || {};\n  const email: string | undefined = activeAccounts[projectDir];\n\n  if (!email) {\n    return getGlobalDefaultAccount();\n  }\n\n  const allAccounts = getAllAccounts();\n  return allAccounts.find((a) => a.user.email === email);\n}\n\n/**\n * Get all authenticated accounts _besides_ the default account.\n */\nexport function getAdditionalAccounts(): Account[] {\n  return configstore.get(\"additionalAccounts\") || [];\n}\n\n/**\n * Get all authenticated accounts.\n */\nexport function getAllAccounts(): Account[] {\n  const res: Account[] = [];\n\n  const defaultUser = getGlobalDefaultAccount();\n  if (defaultUser) {\n    res.push(defaultUser);\n  }\n\n  res.push(...getAdditionalAccounts());\n\n  return res;\n}\n\n/**\n * Set the globally active account. Modifies the options object\n * and sets global refresh token state.\n * @param options options object.\n * @param account account to make active.\n */\nexport function setActiveAccount(options: any, account: Account) {\n  if (account.tokens.refresh_token) {\n    setRefreshToken(account.tokens.refresh_token);\n  }\n\n  options.user = account.user;\n  options.tokens = account.tokens;\n}\n\n/**\n * Set the global refresh token in both api and apiv2.\n * @param token refresh token string\n */\nexport function setRefreshToken(token: string) {\n  apiv2.setRefreshToken(token);\n}\n\n/**\n * Select the right account to use based on the --account flag and the\n * project defaults.\n * @param account the --account flag, if passed.\n * @param projectRoot the Firebase project root directory, if known.\n */\nexport function selectAccount(account?: string, projectRoot?: string): Account | undefined {\n  const defaultUser = getProjectDefaultAccount(projectRoot);\n\n  // Default to single-account behavior\n  if (!account) {\n    return defaultUser;\n  }\n\n  // Ensure that the user exists if specified\n  if (!defaultUser) {\n    throw new FirebaseError(`Account ${account} not found, have you run \"firebase login\"?`);\n  }\n\n  const matchingAccount = getAllAccounts().find((a) => a.user.email === account);\n  if (matchingAccount) {\n    return matchingAccount;\n  }\n\n  throw new FirebaseError(\n    `Account ${account} not found, run \"firebase login:list\" to see existing accounts or \"firebase login:add\" to add a new one`\n  );\n}\n\n/**\n * Add an additional account to the login list.\n * @param useLocalhost should the flow be interactive or code-based?\n * @param email an optional hint to use for the google account picker\n */\nexport async function loginAdditionalAccount(useLocalhost: boolean, email?: string) {\n  // Log the user in using the passed email as a hint\n  const result = await loginGoogle(useLocalhost, email);\n\n  // The JWT library can technically return a string, even though it never should.\n  if (typeof result.user === \"string\") {\n    throw new FirebaseError(\"Failed to parse auth response, see debug log.\");\n  }\n\n  const resultEmail = result.user.email;\n  if (email && resultEmail !== email) {\n    utils.logWarning(`Chosen account ${resultEmail} does not match account hint ${email}`);\n  }\n\n  const allAccounts = getAllAccounts();\n\n  const newAccount = {\n    user: result.user,\n    tokens: result.tokens,\n  };\n\n  const existingAccount = allAccounts.find((a) => a.user.email === resultEmail);\n  if (existingAccount) {\n    utils.logWarning(`Already logged in as ${resultEmail}.`);\n    updateAccount(newAccount);\n  } else {\n    const additionalAccounts = getAdditionalAccounts();\n    additionalAccounts.push(newAccount);\n    configstore.set(\"additionalAccounts\", additionalAccounts);\n  }\n\n  return newAccount;\n}\n\n/**\n * Set the default account to use with a Firebase project directory. Writes\n * the setting to disk.\n * @param projectDir the Firebase project directory.\n * @param email email of the account.\n */\nexport function setProjectAccount(projectDir: string, email: string) {\n  logger.debug(`setProjectAccount(${projectDir}, ${email})`);\n  const activeAccounts: Record<string, string> = configstore.get(\"activeAccounts\") || {};\n  activeAccounts[projectDir] = email;\n  configstore.set(\"activeAccounts\", activeAccounts);\n}\n\n/**\n * Set the global default account.\n */\nexport function setGlobalDefaultAccount(account: Account) {\n  configstore.set(\"user\", account.user);\n  configstore.set(\"tokens\", account.tokens);\n\n  const additionalAccounts = getAdditionalAccounts();\n  const index = additionalAccounts.findIndex((a) => a.user.email === account.user.email);\n  if (index >= 0) {\n    additionalAccounts.splice(index, 1);\n    configstore.set(\"additionalAccounts\", additionalAccounts);\n  }\n}\n\nfunction open(url: string): void {\n  opn(url).catch((err) => {\n    logger.debug(\"Unable to open URL: \" + err.stack);\n  });\n}\n\n// Always create a new error so that the stack is useful\nfunction invalidCredentialError(): FirebaseError {\n  return new FirebaseError(\n    \"Authentication Error: Your credentials are no longer valid. Please run \" +\n      clc.bold(\"firebase login --reauth\") +\n      \"\\n\\n\" +\n      \"For CI servers and headless environments, generate a new token with \" +\n      clc.bold(\"firebase login:ci\"),\n    { exit: 1 }\n  );\n}\n\nconst FIFTEEN_MINUTES_IN_MS = 15 * 60 * 1000;\nconst SCOPES = [\n  scopes.EMAIL,\n  scopes.OPENID,\n  scopes.CLOUD_PROJECTS_READONLY,\n  scopes.FIREBASE_PLATFORM,\n  scopes.CLOUD_PLATFORM,\n];\n\nconst _nonce = Math.floor(Math.random() * (2 << 29) + 1).toString();\nconst getPort = portfinder.getPortPromise;\n\n// in-memory cache, so we have it for successive calls\nlet lastAccessToken: TokensWithExpiration | undefined;\n\nfunction getCallbackUrl(port?: number): string {\n  if (typeof port === \"undefined\") {\n    return \"urn:ietf:wg:oauth:2.0:oob\";\n  }\n  return `http://localhost:${port}`;\n}\n\nfunction queryParamString(args: { [key: string]: string | undefined }) {\n  const tokens: string[] = [];\n  for (const [key, value] of Object.entries(args)) {\n    if (typeof value === \"string\") {\n      tokens.push(key + \"=\" + encodeURIComponent(value));\n    }\n  }\n  return tokens.join(\"&\");\n}\n\nfunction getLoginUrl(callbackUrl: string, userHint?: string) {\n  return (\n    authOrigin +\n    \"/o/oauth2/auth?\" +\n    queryParamString({\n      client_id: clientId,\n      scope: SCOPES.join(\" \"),\n      response_type: \"code\",\n      state: _nonce,\n      redirect_uri: callbackUrl,\n      login_hint: userHint,\n    })\n  );\n}\n\nasync function getTokensFromAuthorizationCode(\n  code: string,\n  callbackUrl: string,\n  verifier?: string\n) {\n  const params: Record<string, string> = {\n    code: code,\n    client_id: clientId,\n    client_secret: clientSecret,\n    redirect_uri: callbackUrl,\n    grant_type: \"authorization_code\",\n  };\n\n  if (verifier) {\n    params[\"code_verifier\"] = verifier;\n  }\n\n  let res: apiv2.ClientResponse<TokensWithTTL>;\n  try {\n    const client = new apiv2.Client({ urlPrefix: authOrigin, auth: false });\n    const form = new FormData();\n    for (const [k, v] of Object.entries(params)) {\n      form.append(k, v);\n    }\n    res = await client.request<any, TokensWithTTL>({\n      method: \"POST\",\n      path: \"/o/oauth2/token\",\n      body: form,\n      headers: form.getHeaders(),\n      skipLog: { body: true, queryParams: true, resBody: true },\n    });\n  } catch (err: any) {\n    if (err instanceof Error) {\n      logger.debug(\"Token Fetch Error:\", err.stack || \"\");\n    } else {\n      logger.debug(\"Token Fetch Error\");\n    }\n    throw invalidCredentialError();\n  }\n  if (!res.body.access_token && !res.body.refresh_token) {\n    logger.debug(\"Token Fetch Error:\", res.status, res.body);\n    throw invalidCredentialError();\n  }\n  lastAccessToken = Object.assign(\n    {\n      expires_at: Date.now() + res.body.expires_in! * 1000,\n    },\n    res.body\n  );\n  return lastAccessToken;\n}\n\nconst GITHUB_SCOPES = [\"read:user\", \"repo\", \"public_repo\"];\n\nfunction getGithubLoginUrl(callbackUrl: string) {\n  return (\n    githubOrigin +\n    \"/login/oauth/authorize?\" +\n    queryParamString({\n      client_id: githubClientId,\n      state: _nonce,\n      redirect_uri: callbackUrl,\n      scope: GITHUB_SCOPES.join(\" \"),\n    })\n  );\n}\n\nasync function getGithubTokensFromAuthorizationCode(code: string, callbackUrl: string) {\n  const client = new apiv2.Client({ urlPrefix: githubOrigin, auth: false });\n  const data = {\n    client_id: githubClientId,\n    client_secret: githubClientSecret,\n    code,\n    redirect_uri: callbackUrl,\n    state: _nonce,\n  };\n  const form = new FormData();\n  for (const [k, v] of Object.entries(data)) {\n    form.append(k, v);\n  }\n  const headers = form.getHeaders();\n  headers.accept = \"application/json\";\n  const res = await client.request<any, GitHubAuthResponse>({\n    method: \"POST\",\n    path: \"/login/oauth/access_token\",\n    body: form,\n    headers,\n  });\n  return res.body.access_token;\n}\n\nasync function respondWithFile(\n  req: http.IncomingMessage,\n  res: http.ServerResponse,\n  statusCode: number,\n  filename: string\n) {\n  const response = await util.promisify(fs.readFile)(path.join(__dirname, filename));\n  res.writeHead(statusCode, {\n    \"Content-Length\": response.length,\n    \"Content-Type\": \"text/html\",\n  });\n  res.end(response);\n  req.socket.destroy();\n}\n\nfunction urlsafeBase64(base64string: string) {\n  return base64string.replace(/\\+/g, \"-\").replace(/=+$/, \"\").replace(/\\//g, \"_\");\n}\n\nasync function loginRemotely(): Promise<UserCredentials> {\n  const authProxyClient = new apiv2.Client({\n    urlPrefix: authProxyOrigin,\n    auth: false,\n  });\n\n  const sessionId = uuidv4();\n  const codeVerifier = randomBytes(32).toString(\"hex\");\n  // urlsafe base64 is required for code_challenge in OAuth PKCE\n  const codeChallenge = urlsafeBase64(createHash(\"sha256\").update(codeVerifier).digest(\"base64\"));\n\n  const attestToken = (\n    await authProxyClient.post<{ session_id: string }, { token: string }>(\"/attest\", {\n      session_id: sessionId,\n    })\n  ).body?.token;\n\n  const loginUrl = `${authProxyOrigin}/login?code_challenge=${codeChallenge}&session=${sessionId}&attest=${attestToken}`;\n\n  logger.info();\n  logger.info(\"To sign in to the Firebase CLI:\");\n  logger.info();\n  logger.info(\"1. Take note of your session ID:\");\n  logger.info();\n  logger.info(`   ${clc.bold(sessionId.substring(0, 5).toUpperCase())}`);\n  logger.info();\n  logger.info(\"2. Visit the URL below on any device and follow the instructions to get your code:\");\n  logger.info();\n  logger.info(`   ${loginUrl}`);\n  logger.info();\n  logger.info(\"3. Paste or enter the authorization code below once you have it:\");\n  logger.info();\n\n  const code = await promptOnce({\n    type: \"input\",\n    message: \"Enter authorization code:\",\n  });\n\n  try {\n    const tokens = await getTokensFromAuthorizationCode(\n      code,\n      `${authProxyOrigin}/complete`,\n      codeVerifier\n    );\n\n    void track(\"login\", \"google_remote\");\n\n    return {\n      user: jwt.decode(tokens.id_token!) as User,\n      tokens: tokens,\n      scopes: SCOPES,\n    };\n  } catch (e) {\n    throw new FirebaseError(\"Unable to authenticate using the provided code. Please try again.\");\n  }\n}\n\nasync function loginWithLocalhostGoogle(port: number, userHint?: string): Promise<UserCredentials> {\n  const callbackUrl = getCallbackUrl(port);\n  const authUrl = getLoginUrl(callbackUrl, userHint);\n  const successTemplate = \"../templates/loginSuccess.html\";\n  const tokens = await loginWithLocalhost(\n    port,\n    callbackUrl,\n    authUrl,\n    successTemplate,\n    getTokensFromAuthorizationCode\n  );\n\n  void track(\"login\", \"google_localhost\");\n  // getTokensFromAuthoirzationCode doesn't handle the --token case, so we know we'll\n  // always have an id_token.\n  return {\n    user: jwt.decode(tokens.id_token!) as User,\n    tokens: tokens,\n    scopes: tokens.scopes!,\n  };\n}\n\nasync function loginWithLocalhostGitHub(port: number): Promise<string> {\n  const callbackUrl = getCallbackUrl(port);\n  const authUrl = getGithubLoginUrl(callbackUrl);\n  const successTemplate = \"../templates/loginSuccessGithub.html\";\n  const tokens = await loginWithLocalhost(\n    port,\n    callbackUrl,\n    authUrl,\n    successTemplate,\n    getGithubTokensFromAuthorizationCode\n  );\n  void track(\"login\", \"google_localhost\");\n  return tokens;\n}\n\nasync function loginWithLocalhost<ResultType>(\n  port: number,\n  callbackUrl: string,\n  authUrl: string,\n  successTemplate: string,\n  getTokens: (queryCode: string, callbackUrl: string) => Promise<ResultType>\n): Promise<ResultType> {\n  return new Promise<ResultType>((resolve, reject) => {\n    const server = http.createServer(async (req, res) => {\n      const query = url.parse(`${req.url}`, true).query || {};\n      const queryState = query.state;\n      const queryCode = query.code;\n\n      if (queryState !== _nonce || typeof queryCode !== \"string\") {\n        await respondWithFile(req, res, 400, \"../templates/loginFailure.html\");\n        reject(new FirebaseError(\"Unexpected error while logging in\"));\n        server.close();\n        return;\n      }\n\n      try {\n        const tokens = await getTokens(queryCode, callbackUrl);\n        await respondWithFile(req, res, 200, successTemplate);\n        resolve(tokens);\n      } catch (err: any) {\n        await respondWithFile(req, res, 400, \"../templates/loginFailure.html\");\n        reject(err);\n      }\n      server.close();\n      return;\n    });\n\n    server.listen(port, () => {\n      logger.info();\n      logger.info(\"Visit this URL on this device to log in:\");\n      logger.info(clc.bold(clc.underline(authUrl)));\n      logger.info();\n      logger.info(\"Waiting for authentication...\");\n\n      open(authUrl);\n    });\n\n    server.on(\"error\", (err) => {\n      reject(err);\n    });\n  });\n}\n\nexport async function loginGoogle(localhost: boolean, userHint?: string): Promise<UserCredentials> {\n  if (localhost) {\n    try {\n      const port = await getPort();\n      return await loginWithLocalhostGoogle(port, userHint);\n    } catch {\n      return await loginRemotely();\n    }\n  }\n  return await loginRemotely();\n}\n\nexport async function loginGithub(): Promise<string> {\n  const port = await getPort();\n  return loginWithLocalhostGitHub(port);\n}\n\nexport function findAccountByEmail(email: string): Account | undefined {\n  return getAllAccounts().find((a) => a.user.email === email);\n}\n\nfunction haveValidTokens(refreshToken: string, authScopes: string[]) {\n  if (!lastAccessToken?.access_token) {\n    const tokens = configstore.get(\"tokens\");\n    if (refreshToken === tokens?.refresh_token) {\n      lastAccessToken = tokens;\n    }\n  }\n\n  const hasTokens = !!lastAccessToken?.access_token;\n  const oldScopesJSON = JSON.stringify(lastAccessToken?.scopes?.sort() || []);\n  const newScopesJSON = JSON.stringify(authScopes.sort());\n  const hasSameScopes = oldScopesJSON === newScopesJSON;\n  // To avoid token expiration in the middle of a long process we only hand out\n  // tokens if they have a _long_ time before the server rejects them.\n  const isExpired = (lastAccessToken?.expires_at || 0) < Date.now() + FIFTEEN_MINUTES_IN_MS;\n\n  return hasTokens && hasSameScopes && !isExpired;\n}\n\nfunction deleteAccount(account: Account) {\n  // Check the global default user\n  const defaultAccount = getGlobalDefaultAccount();\n  if (account.user.email === defaultAccount?.user.email) {\n    configstore.delete(\"user\");\n    configstore.delete(\"tokens\");\n    configstore.delete(\"usage\");\n    configstore.delete(\"analytics-uuid\");\n  }\n\n  // Check all additional users\n  const additionalAccounts = getAdditionalAccounts();\n  const remainingAccounts = additionalAccounts.filter((a) => a.user.email !== account.user.email);\n  configstore.set(\"additionalAccounts\", remainingAccounts);\n\n  // Clear any matching project defaults\n  const activeAccounts: Record<string, string> = configstore.get(\"activeAccounts\") || {};\n  for (const [projectDir, projectAccount] of Object.entries(activeAccounts)) {\n    if (projectAccount === account.user.email) {\n      delete activeAccounts[projectDir];\n    }\n  }\n  configstore.set(\"activeAccounts\", activeAccounts);\n}\n\nfunction updateAccount(account: Account) {\n  const defaultAccount = getGlobalDefaultAccount();\n  if (account.user.email === defaultAccount?.user.email) {\n    configstore.set(\"user\", account.user);\n    configstore.set(\"tokens\", account.tokens);\n  }\n\n  const additionalAccounts = getAdditionalAccounts();\n  const accountIndex = additionalAccounts.findIndex((a) => a.user.email === account.user.email);\n  if (accountIndex >= 0) {\n    additionalAccounts.splice(accountIndex, 1, account);\n    configstore.set(\"additionalAccounts\", additionalAccounts);\n  }\n}\n\nfunction findAccountByRefreshToken(refreshToken: string): Account | undefined {\n  return getAllAccounts().find((a) => a.tokens.refresh_token === refreshToken);\n}\n\nfunction logoutCurrentSession(refreshToken: string) {\n  const account = findAccountByRefreshToken(refreshToken);\n  if (!account) {\n    return;\n  }\n\n  clearCredentials(account);\n  deleteAccount(account);\n}\n\nasync function refreshTokens(\n  refreshToken: string,\n  authScopes: string[]\n): Promise<TokensWithExpiration> {\n  logger.debug(\"> refreshing access token with scopes:\", JSON.stringify(authScopes));\n  try {\n    const client = new apiv2.Client({ urlPrefix: googleOrigin, auth: false });\n    const data = {\n      refresh_token: refreshToken,\n      client_id: clientId,\n      client_secret: clientSecret,\n      grant_type: \"refresh_token\",\n      scope: (authScopes || []).join(\" \"),\n    };\n    const form = new FormData();\n    for (const [k, v] of Object.entries(data)) {\n      form.append(k, v);\n    }\n    const res = await client.request<FormData, TokensWithTTL>({\n      method: \"POST\",\n      path: \"/oauth2/v3/token\",\n      body: form,\n      headers: form.getHeaders(),\n      skipLog: { body: true, queryParams: true, resBody: true },\n      resolveOnHTTPError: true,\n    });\n    if (res.status === 401 || res.status === 400) {\n      // Support --token <token> commands. In this case we won't have an expiration\n      // time, scopes, etc.\n      return { access_token: refreshToken };\n    }\n\n    if (typeof res.body.access_token !== \"string\") {\n      throw invalidCredentialError();\n    }\n    lastAccessToken = Object.assign(\n      {\n        expires_at: Date.now() + res.body.expires_in! * 1000,\n        refresh_token: refreshToken,\n        scopes: authScopes,\n      },\n      res.body\n    );\n\n    const account = findAccountByRefreshToken(refreshToken);\n    if (account && lastAccessToken) {\n      account.tokens = lastAccessToken;\n      updateAccount(account);\n    }\n\n    return lastAccessToken!;\n  } catch (err: any) {\n    if (err?.context?.body?.error === \"invalid_scope\") {\n      throw new FirebaseError(\n        \"This command requires new authorization scopes not granted to your current session. Please run \" +\n          clc.bold(\"firebase login --reauth\") +\n          \"\\n\\n\" +\n          \"For CI servers and headless environments, generate a new token with \" +\n          clc.bold(\"firebase login:ci\"),\n        { exit: 1 }\n      );\n    }\n\n    throw invalidCredentialError();\n  }\n}\n\nexport async function getAccessToken(refreshToken: string, authScopes: string[]) {\n  if (haveValidTokens(refreshToken, authScopes)) {\n    return lastAccessToken;\n  }\n\n  return refreshTokens(refreshToken, authScopes);\n}\n\nexport async function logout(refreshToken: string) {\n  if (lastAccessToken?.refresh_token === refreshToken) {\n    lastAccessToken = undefined;\n  }\n  logoutCurrentSession(refreshToken);\n  try {\n    const client = new apiv2.Client({ urlPrefix: authOrigin, auth: false });\n    await client.get(\"/o/oauth2/revoke\", { queryParams: { token: refreshToken } });\n  } catch (thrown: any) {\n    const err: Error = thrown instanceof Error ? thrown : new Error(thrown);\n    throw new FirebaseError(\"Authentication Error.\", {\n      exit: 1,\n      original: err,\n    });\n  }\n}\n"],"names":["cachedSetTimeout","cachedClearTimeout","process","module","exports","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","setTimeout","e","call","this","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","Array","arguments","i","push","prototype","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","DEFAULT_PORTS","ui","hub","logging","hosting","functions","extensions","firestore","pubsub","database","auth","storage","eventarc","EMULATOR_DESCRIPTION","Constants","static","service","SERVICE_FIRESTORE","SERVICE_REALTIME_DATABASE","SERVICE_PUBSUB","SERVICE_ANALYTICS","SERVICE_AUTH","SERVICE_CRASHLYTICS","SERVICE_REMOTE_CONFIG","SERVICE_STORAGE","SERVICE_TEST_LAB","SERVICE_EVENTARC","emulator","projectId","startsWith","FAKE_PROJECT_ID_PREFIX","FAKE_PROJECT_NUMBER","DEFAULT_DATABASE_EMULATOR_NAMESPACE","FIRESTORE_EMULATOR_HOST","FIRESTORE_EMULATOR_ENV_ALT","FIREBASE_DATABASE_EMULATOR_HOST","FIREBASE_AUTH_EMULATOR_HOST","FIREBASE_STORAGE_EMULATOR_HOST","CLOUD_STORAGE_EMULATOR_HOST","PUBSUB_EMULATOR_HOST","CLOUD_EVENTARC_EMULATOR_HOST","FIREBASE_EMULATOR_HUB","FIREBASE_GA_SESSION","commandScopes","Set","authProxyOrigin","utils","clientId","clientSecret","cloudbillingOrigin","cloudloggingOrigin","cloudMonitoringOrigin","containerRegistryDomain","artifactRegistryDomain","appDistributionOrigin","appengineOrigin","authOrigin","consoleOrigin","deployOrigin","dynamicLinksOrigin","dynamicLinksKey","firebaseApiOrigin","firebaseExtensionsRegistryOrigin","firedataOrigin","firestoreOriginOrEmulator","val","firestoreOrigin","functionsOrigin","functionsV2Origin","runOrigin","functionsDefaultRegion","cloudschedulerOrigin","cloudTasksOrigin","pubsubOrigin","googleOrigin","hostingOrigin","identityOrigin","iamOrigin","extensionsOrigin","realtimeOrigin","rtdbManagementOrigin","rtdbMetadataOrigin","remoteConfigApiOrigin","resourceManagerOrigin","rulesOrigin","runtimeconfigOrigin","storageOrigin","firebaseStorageOrigin","hostingApiOrigin","cloudRunApiOrigin","serviceUsageOrigin","githubOrigin","githubApiOrigin","secretManagerOrigin","githubClientId","githubClientSecret","getScopes","from","setScopes","sps","scopes","s","add","logger","configstore","require","FirebaseError","constructor","message","options","super","children","defaultTo","context","exit","original","status","rawLogger","silent","exitOnError","debug","bind","meta","Date","toISOString","annotateDebugLines","oldLogFunc","log","levelOrEntry","stack","expandErrors","OPENID","EMAIL","CLOUD_PROJECTS_READONLY","FIREBASE_PLATFORM","CLOUD_PLATFORM","envOverrides","envOverride","envname","value","coerce","currentEnvValue","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","hasOwnProperty","r","Symbol","toStringTag","FIREBASE_EMULATOR_GA4_MEASUREMENT_ID","FIREBASE_ANALYTICS_UA","anonId","c","visitor","strictCidFormat","https","activate","console","disposable","account","user","tokens","JSON","stringify","email","subscriptions","deactivate","set","platform","FIREPIT_VERSION","FIREBASE_EMULATOR_GA4_API_SECRET","Math","floor","random","toString"],"sourceRoot":""}